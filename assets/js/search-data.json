{
  
    
        "post0": {
            "title": "Speed-up inference with Batch Normalization Folding",
            "content": "Introduction . Batch Normalization is a technique which takes care of normalizing the input of each layer to make the training process faster and more stable. In practice, it is an extra layer that we generally add after the computation layer and before the non-linearity. . It consists of 2 steps: . Normalize the batch by first subtracting its mean $ mu$, then dividing it by its standard deviation $ sigma$. | Further scale by a factor $ gamma$ and shift by a factor $ beta$. Those are the parameters of the batch normalization layer, required in case of the network not needing the data to have a mean of 0 and a standard deviation of 1. | μB←1m∑i=1mxiσB2←1m∑i=1m(xi−μB)2x^i←xi−μBσB2+ϵyi←γx^i+β≡BNγ,β(xi) Large begin{aligned} &amp; mu_{ mathcal{B}} leftarrow frac{1}{m} sum_{i=1}^{m} x_{i} &amp; sigma_{ mathcal{B}}^{2} leftarrow frac{1}{m} sum_{i=1}^{m} left(x_{i}- mu_{ mathcal{B}} right)^{2} &amp; widehat{x}_{i} leftarrow frac{x_{i}- mu_{ mathcal{B}}}{ sqrt{ sigma_{ mathcal{B}}^{2}+ epsilon}} &amp;y_{i} leftarrow gamma widehat{x}_{i}+ beta equiv mathrm{BN}_{ gamma, beta} left(x_{i} right) end{aligned}​μB​←m1​i=1∑m​xi​σB2​←m1​i=1∑m​(xi​−μB​)2x . i​←σB2​+ϵ . ​xi​−μB​​yi​←γx . i​+β≡BNγ,β​(xi​)​ . Due to its efficiency for training neural networks, batch normalization is now widely used. But how useful is it at inference time? . Once the training has ended, each batch normalization layer possesses a specific set of $ gamma$ and $ beta$, but also $ mu$ and $ sigma$, the latter being computed using an exponentially weighted average during training. It means that during inference, the batch normalization acts as a simple linear transformation of what comes out of the previous layer, often a convolution. . As a convolution is also a linear transformation, it also means that both operations can be merged into a single linear transformation! . This would remove some unnecessary parameters but also reduce the number of operations to be performed at inference time. . . How to do that in practice? . With a little bit of math, we can easily rearrange the terms of the convolution to take the batch normalization into account. . As a little reminder, the convolution operation followed by the batch normalization operation can be expressed, for an input $x$, as: . z=W∗x+b out =γ⋅z−μσ2+ϵ+β Large begin{aligned} z &amp;=W * x+b text { out } &amp;= gamma cdot frac{z- mu}{ sqrt{ sigma^{2}+ epsilon}}+ beta end{aligned}z out ​=W∗x+b=γ⋅σ2+ϵ . ​z−μ​+β​ . So, if we re-arrange the $W$ and $b$ of the convolution to take the parameters of the batch normalization into account, as such: . wfold =γ⋅Wσ2+ϵbfold =γ⋅b−μσ2+ϵ+β Large begin{aligned} w_{ text {fold }} &amp;= gamma cdot frac{W}{ sqrt{ sigma^{2}+ epsilon}} b_{ text {fold }} &amp;= gamma cdot frac{b- mu}{ sqrt{ sigma^{2}+ epsilon}}+ beta end{aligned}wfold ​bfold ​​=γ⋅σ2+ϵ . ​W​=γ⋅σ2+ϵ . ​b−μ​+β​ . We can remove the batch normalization layer and still have the same results! . Note: Usually, you don’t have a bias in a layer preceding a batch normalization layer. It is useless and a waste of parameters as any constant will be canceled out by the batch normalization. . . How efficient is it? . We will try for 2 common architectures: . VGG16 with batch norm | ResNet50 | Just for the demonstration, we will use ImageNette dataset and PyTorch. Both networks will be trained for 5 epochs and what changes in terms of parameter number and inference time. . VGG16 . Let’s start by training VGG16 for 5 epochs (the final accuracy doesn’t matter): . . Then show its number of parameters: . . The initial inference time for a single image is: . . So now if we apply batch normalization folding, we have: . . And: . . So 8448 parameters removed and even better, almost 0.4 ms faster inference! Most importantly, this is completely lossless, there is absolutely no change in terms of performance: . Let’s see how it behaves in the case of Resnet50! . Resnet50 . Same, we start by training it for 5 epochs: . . The initial amount of parameters is: . . And inference time is: . . After using batch normalization folding, we have: . . And: . . So now, we have 26,560 parameters removed and even more impressive, an inference time reduce by 1.5ms! And still without any drop in performance. . So if we can reduce the inference time and the number of parameters of our models without enduring any drop in performance, why shouldn’t we always do it? . I hope that this blog post helped you! Feel free to give me feedback or ask me questions is something is not clear enough. . Code available at this address! . . References and further readings: . The Batch Normalization paper | DeepLearning.ai Batch Normalization Lesson | .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2020/04/20/BN-folding.html",
            "relUrl": "/deep%20learning/2020/04/20/BN-folding.html",
            "date": " • Apr 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(movies).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(movies).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=alt.Y(&#39;IMDB_Rating:Q&#39;, axis=alt.Axis(minExtent=30)), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=600, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=700, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; df = pd.read_json(movies) # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://nathanhubens.github.io/posts/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Build a simple Image Retrieval System with an Autoencoder",
            "content": "Image retrieval is a very active and fast-advancing field of research area in the past decade. The most well-known systems being the Google Image Search and Pinterest Visual Pin Search. In this article, we will learn to build a very simple image retrieval system using a special type of Neural Network, called an autoencoder. The way we are going to proceed is in an unsupervised way, i.e without looking at the image labels. Indeed, we will retrieve images only by using their visual contents (textures, shapes,…). This type of image retrieval is called content-based image retrieval (CBIR), opposed to keywords or text-based image retrieval. For this article, we will use images of handwritten digits, the MNIST dataset and the Keras deep-learning framework. . . Autoencoders . Briefly, autoencoders are neural networks that aims to copy their inputs to their outputs. They work by compressing the input into a latent-space representation, and then reconstructing the output from this representation.This kind of network is composed of two parts : . Encoder: This is the part of the network that compresses the input into a latent-space representation. It can be represented by an encoding function $h=f(x)$. . | Decoder: This part aims to reconstruct the input from the latent space representation. It can be represented by a decoding function $r=g(h)$. . | . . If you want to learn more about autoencoders, I suggest you to read my previous blog post. . . This latent representation, or code, is what will interest us here as it is the way the neural network as found to compress the visual content about each image. It means that all of similar images will be encoded (hopefully) in a similar way. There are several types of autoencoders but since we are dealing with images, the most efficient is to use a convolutional autoencoder, that uses convolution layers to encode and decode images. . x = Input(shape=(28, 28, 1)) # Encoder conv1_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) # Decoder conv2_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . The first step is thus to train our autoencoder with our training set, to make it learn the way to encode our images into a latent-space representation. Once the training as been performed, we only need the encoding part of the network. . encoder = Model(inputs=autoencoder.input, outputs=autoencoder.get_layer(&#39;encoder&#39;).output) . This encoder can now be used to encode our query image. . . The same encoding must be done on our searching database, where we want to find similar images to the query image. We can then compare the query code to the database code and try to find the closest ones. To perform this comparison, we will use the nearest-neighbors technique. . Nearest-neighbors . The way we are going to retrieve the closest codes is by performing the nearest-neighbors algorithm. The principle behind nearest neighbor methods is to find a predefined number of samples closest in distance to the new point. The distance can be any metric measure but the most common choice is the Euclidean distance. For a query image $q$ and a sample $s$, both of dimension $n$, this distance can be computed by the following formula. . begin{equation} d(q,s) = sqrt{(q_1-s_1)^2 + (q_2-s_2)^2 + … + (q_n-s_n)^2} end{equation} . In this example, we will retrieve the 5 closest images to the query image. . # Fit the NN algorithm to the encoded test set nbrs = NearestNeighbors(n_neighbors=5).fit(codes) # Find the closest images to the encoded query image distances, indices = nbrs.kneighbors(np.array(query_code)) . Results . These are the images we retrieved, it looks great ! All the retrieved images are pretty similar to our query image and they also all correspond to the same digit. This shows that the autoencoder, even without being shown the corresponding labels of the images, has found a way to encode similar images in a very similar way. . . Summary . In this article, we learned to create a very simple image retrieval system by using an autoencoder and the nearest-neighbors algorithm. We proceeded by training our autoencoder on a big dataset, to make it learn the way to encode efficiently the visual content of each image. We then compared the code of our query image to the codes of our searching dataset and retrieve the 5 closest. We saw that our system was giving pretty good results as the visual content of our 5 retrieved images was close to our query image and also that they all represented the same digit, even without using any label in the process. . . I hope this article was clear and useful for new Deep Learning practitioners and that it gave you a good insight on what image retrieval with autoencoders looks like ! Feel free to give me feedback or ask me questions is something is not clear enough. The whole code is available at this address! .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2018/08/24/image-retrieval.html",
            "relUrl": "/deep%20learning/2018/08/24/image-retrieval.html",
            "date": " • Aug 24, 2018"
        }
        
    
  
    
        ,"post3": {
            "title": "Deep Inside Autoencoders",
            "content": "Introduction . Autoencoders (AE) are neural networks that aims to copy their inputs to their outputs. They work by compressing the input into a latent-space representation, and then reconstructing the output from this representation. This kind of network is composed of two parts : . Encoder: This is the part of the network that compresses the input into a latent-space representation. It can be represented by an encoding function h=f(x)h=f(x)h=f(x). | Decoder: This part aims to reconstruct the input from the latent space representation. It can be represented by a decoding function $r=g(h)$. | . . Architecture of an Autoencoder . The autoencoder as a whole can thus be described by the function g(f(x))=rg(f(x)) = rg(f(x))=r where you want rrr as close as the original input xxx. . Why copying the input to the output ? . If the only purpose of autoencoders was to copy the input to the output, they would be useless. Indeed, we hope that, by training the autoencoder to copy the input to the output, the latent representation hhh will take on useful properties. . This can be achieved by creating constraints on the copying task. One way to obtain useful features from the autoencoder is to constrain hhh to have smaller dimensions than xxx, in this case the autoencoder is called undercomplete. By training an undercomplete representation, we force the autoencoder to learn the most salient features of the training data. If the autoencoder is given too much capacity, it can learn to perform the copying task without extracting any useful information about the distribution of the data. This can also occur if the dimension of the latent representation is the same as the input, and in the overcomplete case, where the dimension of the latent representation is greater than the input. In these cases, even a linear encoder and linear decoder can learn to copy the input to the output without learning anything useful about the data distribution. Ideally, one could train any architecture of autoencoder successfully, choosing the code dimension and the capacity of the encoder and decoder based on the complexity of distribution to be modeled. . . What are autoencoders used for ? . Today data denoising and dimensionality reduction for data visualization are considered as two main interesting practical applications of autoencoders. With appropriate dimensionality and sparsity constraints, autoencoders can learn data projections that are more interesting than PCA or other basic techniques. Autoencoders are learned automatically from data examples. It means that it is easy to train specialized instances of the algorithm that will perform well on a specific type of input and that it does not require any new engineering, only the appropriate training data. . However, autoencoders will do a poor job for image compression. As the autoencoder is trained on a given set of data, it will achieve reasonable compression results on data similar to the training set used but will be poor general-purpose image compressors. Compression techniques like JPEG will do vastly better. Autoencoders are trained to preserve as much information as possible when an input is run through the encoder and then the decoder, but are also trained to make the new representation have various nice properties. Different kinds of autoencoders aim to achieve different kinds of properties. We will focus on four types on autoencoders. . . Types of autoencoder : . In this article, the four following types of autoencoders will be described: . Vanilla autoencoder | Multilayer autoencoder | Convolutional autoencoder | Regularized autoencoder | . In order to illustrate the different types of autoencoder, an example of each has been created, using the Keras framework and the MNIST dataset. The code for each type of autoencoder is available on my GitHub. . Vanilla autoencoder . In its simplest form, the autoencoder is a three layers net, i.e. a neural net with one hidden layer. The input and output are the same, and we learn how to reconstruct the input, for example using the adam optimizer and the mean squared error loss function. . input_size = 784 hidden_size = 64 output_size = 784 x = Input(shape=(input_size,)) # Encoder h = Dense(hidden_size, activation=&#39;relu&#39;)(x) # Decoder r = Dense(output_size, activation=&#39;sigmoid&#39;)(h) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Here, we see that we have an undercomplete autoencoder as the hidden layer dimension (64) is smaller than the input (784). This constraint will impose our neural net to learn a compressed representation of data. . Multilayer autoencoder . If one hidden layer is not enough, we can obviously extend the autoencoder to more hidden layers. . input_size = 784 hidden_size = 128 code_size = 64 x = Input(shape=(input_size,)) # Encoder hidden_1 = Dense(hidden_size, activation=&#39;relu&#39;)(x) h = Dense(code_size, activation=&#39;relu&#39;)(hidden_1) # Decoder hidden_2 = Dense(hidden_size, activation=&#39;relu&#39;)(h) r = Dense(input_size, activation=&#39;sigmoid&#39;)(hidden_2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Now our implementation uses 3 hidden layers instead of just one. Any of the hidden layers can be picked as the feature representation but we will make the network symmetrical and use the middle-most layer. . Convolutional autoencoder . We may also ask ourselves: can autoencoders be used with Convolutions instead of Fully-connected layers ? . The answer is yes and the principle is the same, but using images (3D vectors) instead of flattened 1D vectors. The input image is downsampled to give a latent representation of smaller dimensions and force the autoencoder to learn a compressed version of the images. . x = Input(shape=(28, 28,1)) # Encoder conv1_1 = Conv2D(16, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) pool2 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) conv1_3 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool2) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_3) # Decoder conv2_1 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) conv2_3 = Conv2D(16, (3, 3), activation=&#39;relu&#39;)(up2) up3 = UpSampling2D((2, 2))(conv2_3) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up3) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Regularized autoencoder . There are other ways we can constraint the reconstruction of an autoencoder than to impose a hidden layer of smaller dimension than the input. Rather than limiting the model capacity by keeping the encoder and decoder shallow and the code size small, regularized autoencoders use a loss function that encourages the model to have other properties besides the ability to copy its input to its output. In practice, we usually find two types of regularized autoencoder: the sparse autoencoder and the denoising autoencoder. . Sparse autoencoder: Sparse autoencoders are typically used to learn features for another task such as classification. An autoencoder that has been regularized to be sparse must respond to unique statistical features of the dataset it has been trained on, rather than simply acting as an identity function. In this way, training to perform the copying task with a sparsity penalty can yield a model that has learned useful features as a byproduct. Another way we can constraint the reconstruction of autoencoder is to impose a constraint in its loss. We could, for example, add a reguralization term in the loss function. Doing this will make our autoencoder learn sparse representation of data. . input_size = 784 hidden_size = 64 output_size = 784 x = Input(shape=(input_size,)) # Encoder h = Dense(hidden_size, activation=&#39;relu&#39;, activity_regularizer=regularizers.l1(10e-5))(x) # Decoder r = Dense(output_size, activation=&#39;sigmoid&#39;)(h) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Notice in our hidden layer, we added an l1 activity regularizer, that will apply a penalty to the loss function during the optimization phase. As a result, the representation is now sparser compared to the vanilla autoencoder. . Denoising autoencoder : Rather than adding a penalty to the loss function, we can obtain an autoencoder that learns something useful by changing the reconstruction error term of the loss function. This can be done by adding some noise of the input image and make the autoencoder learn to remove it. By this means, the encoder will extract the most important features and learn a robuster representation of the data. . x = Input(shape=(28, 28, 1)) # Encoder conv1_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) # Decoder conv2_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . . Summary . In this article, we went through the basic architecture of autoencoders. We also looked at many different types of autoencoders: vanilla, multilayer, convolutional and regularized. Each has different properties depending on the imposed constraints : either the reduced dimension of the hidden layers or another kind of penalty. . . I hope this article was clear and useful for new Deep Learning practitioners and that it gave you a good insight on what autoencoders are ! Feel free to give me feed back or ask me questions is something is not clear enough. The whole code is available at this address! .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2018/02/25/deep-inside-autoencoders.html",
            "relUrl": "/deep%20learning/2018/02/25/deep-inside-autoencoders.html",
            "date": " • Feb 25, 2018"
        }
        
    
  

  
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nathanhubens.github.io/posts/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}