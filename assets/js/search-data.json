{
  
    
        "post0": {
            "title": "Winning the Lottery with fastai",
            "content": ". Introduction . Creating sparse neural networks is a very hot topic at the moment. It is believed to make them smaller, faster and with better generalization capabilities1. For a long time however, it was believed that sparse networks were difficult to train. The traditional way of getting them was therefore to first train a dense network to convergence, then prune it to make it sparse, eventually fine-tuning it a tiny bit more to recover performance. However, some recent research has shown that not only it was possible to train sparse networks, but also that they may outperform their more-parameterized, dense, counterpart. The paper that initiated this trend talks about &quot;lottery tickets&quot;, that may be hidden in neural networks2. In this blog post, we are going to explain what they are and how we can find them, with the help of fastai, and more particularly fasterai, a library to create smaller and faster neural networks that we created. . . . Lottery Ticket Hypothesis . Let&#39;s first introduce what The Lottery Ticket Hypothesis is for those who may have never heard about it. It is a fascinating characteristic of neural networks that has been discovered by Frankle and Carbin in 20192. The gist of this hypothesis can be phrased as the following: . . In a neural network, there exists a subnetwork that can be trained to at least the same accuracy and in at most the same training time as the whole network. The only condition being that both this sub- and the complete networks start from the same initial conditions. . . This subnetwork, called the &quot;winning ticket&quot; (as it is believed to have won at the initialization lottery), can be found by using pruning on the network, removing useless connections. . The steps to unveil this winning ticket are: . Get a freshly initialized network, possessing a set of weights $W_0$ | Train it for a certain amount $T$ of iterations, giving us the network with weights $W_T$ | Prune a portion of the smallest weights, i.e. the weights that possess the lowest $l_1$-norm, giving us the network with weights $W_T odot m$, with $m$ being a binary mask constituted of $0$ for weights we want to remove and $1$ for those we want to keep. | Reinitialize the remaining weights to their original value, i.e. their value at step 1), giving us the network with weights $W_0 odot m$. | Stop if target sparsity is reached or go back to step 2) | . . . We will conduct this tutorial by using a ResNet-18 architecture, trained on Imagenette, a subpart of Imagenet using only 10 classes. . We first want a baseline of the complete model that we can then compare to. . learn = Learner(dls, resnet18(num_classes=10), metrics=accuracy) . Let&#39;s save the weights of this model, so that we can be sure to start from the exact same network in our further experiments. . initial_weights = deepcopy(learn.model.state_dict()) . As this is our baseline, it will not be pruned. Thus, this model corresponds to $W_T$, with $T$ chosen to be $5$ epochs. So let&#39;s train it and report the final accuracy. . learn.fit(5) . epoch train_loss valid_loss accuracy time . 0 | 1.536754 | 1.709699 | 0.481529 | 00:11 | . 1 | 1.254531 | 1.314451 | 0.578089 | 00:11 | . 2 | 1.116412 | 1.168404 | 0.634904 | 00:11 | . 3 | 1.023481 | 1.156428 | 0.633376 | 00:11 | . 4 | 0.946494 | 0.998459 | 0.677962 | 00:11 | . After training, our baseline network is $68 %$ accurate at discriminating between the 10 classes of our validation set. . . Can we please find winning tickets now ? . . We have already shown in a previous blog post how to prune a network with fasterai. As a quick reminder, this can be done by using the SparsifyCallback callback during training. . The only things to specify in the callback are: . end_sparsity, the target final level of sparsity in the network | granularity, the shape of parameters to remove, e.g. weight or filter | method, either prune the weights in each layer separately (local) or in the whole network (global) | criteria, i.e. how to score the importance of parameters to remove | schedule, i.e. when pruning is applied during training | . In the original paper, authors discover tickets using an Iterative Magnitude Pruning (IMP), meaning that the pruning is performed iteratively, with a criteria based on magnitude, i.e. the $l_1$-norm of weights. Authors also specify that they remove individual weights, comparing them across the network globally. . . Luckily for us, all of these were already available in fasterai! We now know most of the parameters of our callback: SparsifyCallback(end_sparsity, granularity=&#39;weight&#39;, method=&#39;global&#39;, criteria=large_final, schedule=iterative) . We are all set then ! Well almost... If you remember correctly the 5 steps presented earlier, we need to keep track of the set of weights $W_0$, at initialization. We also need to reset our weights to their initial value after each pruning step. . In fasterai this can be done by: . passing the lth argument to True. Behind the hood, fasterai will save the initial weights of the model and reset them after each pruning step | Optionnally setting a start_epoch, which affects at which epoch the pruning process will start. | . . Let&#39;s recreate the exact same model as the one we used for baseline. . learn = Learner(dls, resnet18(num_classes=10), metrics=accuracy) learn.model.load_state_dict(initial_weights) . &lt;All keys matched successfully&gt; . In fasterai, the iterative schedule has 3 steps by default, which can easily be changed but we&#39;ll stick with it for our experiments. . We&#39;ll thus have 3 rounds of pruning, and that our network will therefor be reset 3 times. As we want the network to be trained for $T=5$ epochs at each round, this means that the total epochs over which pruning will occur is $3 times 5 = 15$ epochs. . But before performing any round of pruning, there is first a pretraining phase of $T$ epochs. The total number of epochs is then $20$. . Let&#39;s train this bad boy and see what happens ! . sp_cb = SparsifyCallback(50, &#39;weight&#39;, &#39;global&#39;, large_final, iterative, start_epoch=5, lth=True) learn.fit(20, cbs=sp_cb) . Pruning of weight until a sparsity of 50% Saving Weights at epoch 0 . epoch train_loss valid_loss accuracy time . 0 | 1.541520 | 1.568734 | 0.501911 | 00:11 | . 1 | 1.258532 | 1.628220 | 0.508790 | 00:11 | . 2 | 1.111838 | 1.292680 | 0.596688 | 00:11 | . 3 | 1.024304 | 1.385538 | 0.581146 | 00:11 | . 4 | 0.930883 | 1.041547 | 0.672102 | 00:11 | . 5 | 1.330930 | 1.395270 | 0.520510 | 00:20 | . 6 | 1.141437 | 1.135004 | 0.620637 | 00:20 | . 7 | 1.040761 | 1.267395 | 0.581656 | 00:20 | . 8 | 0.952175 | 1.272328 | 0.594650 | 00:20 | . 9 | 0.909871 | 1.207141 | 0.629554 | 00:20 | . 10 | 1.235558 | 1.197264 | 0.598217 | 00:20 | . 11 | 1.042131 | 1.067109 | 0.658854 | 00:20 | . 12 | 0.927392 | 0.977499 | 0.673376 | 00:20 | . 13 | 0.888816 | 0.916399 | 0.699873 | 00:20 | . 14 | 0.800480 | 0.774320 | 0.743439 | 00:20 | . 15 | 1.052142 | 1.027188 | 0.665223 | 00:19 | . 16 | 0.921996 | 0.945266 | 0.694268 | 00:20 | . 17 | 0.831712 | 0.868593 | 0.717452 | 00:19 | . 18 | 0.812539 | 1.016729 | 0.673376 | 00:19 | . 19 | 0.764737 | 0.859072 | 0.725860 | 00:19 | . Sparsity at the end of epoch 0: 0.00% Sparsity at the end of epoch 1: 0.00% Sparsity at the end of epoch 2: 0.00% Sparsity at the end of epoch 3: 0.00% Sparsity at the end of epoch 4: 0.00% Resetting Weights to their epoch 0 values Sparsity at the end of epoch 5: 16.67% Sparsity at the end of epoch 6: 16.67% Sparsity at the end of epoch 7: 16.67% Sparsity at the end of epoch 8: 16.67% Sparsity at the end of epoch 9: 16.67% Resetting Weights to their epoch 0 values Sparsity at the end of epoch 10: 33.33% Sparsity at the end of epoch 11: 33.33% Sparsity at the end of epoch 12: 33.33% Sparsity at the end of epoch 13: 33.33% Sparsity at the end of epoch 14: 33.33% Resetting Weights to their epoch 0 values Sparsity at the end of epoch 15: 50.00% Sparsity at the end of epoch 16: 50.00% Sparsity at the end of epoch 17: 50.00% Sparsity at the end of epoch 18: 50.00% Sparsity at the end of epoch 19: 50.00% Final Sparsity: 50.00 . As can be seen from the verbose below training results, the weights are reset to their original value every 5 epochs. This can also be observed when looking at the accuracy, which drops after each pruning round. . After each round, the sparsity level is increased, meaning that the binary mask $m$ in $W_T odot m$ has more and more zeroes as the training goes. . The last round, performed at a constant sparsity level of $50 %$, is able to reach $72 %$ of accuracy in 5 epochs, which is better than our baseline ! . . . Lottery Ticket Hypothesis with Rewinding . However, authors noticed that this IMP procedure may fail on deeper networks3, they thus propose to weaken the original Lottery Ticket Hypothesis, making the network to be reset to weights early in training instead of at initialization, i.e. our step 4) now resets the weights to $W_t odot m$ with $t&lt;T$. Such a subnetwork is no longer called a &quot;winning&quot; ticket, but a &quot;matching&quot; ticket. In this case, the regular LTH is just the particular case of $t=0$. . In fasterai, this can be done by changing the rewind_epoch value to the epoch you want your weights to be reset to, everything else stays the same. Let&#39;s try this ! . learn = Learner(dls, resnet18(num_classes=10), metrics=accuracy) learn.model.load_state_dict(initial_weights) sp_cb = SparsifyCallback(50, &#39;weight&#39;, &#39;global&#39;, large_final, iterative, start_epoch=5, lth=True, rewind_epoch=1) learn.fit(20, cbs=sp_cb) . Pruning of weight until a sparsity of 50% . epoch train_loss valid_loss accuracy time . 0 | 1.529935 | 1.430763 | 0.522548 | 00:11 | . 1 | 1.268891 | 1.251196 | 0.603822 | 00:11 | . 2 | 1.141558 | 1.176961 | 0.626497 | 00:11 | . 3 | 1.013069 | 1.312681 | 0.607134 | 00:11 | . 4 | 0.933651 | 0.914163 | 0.695796 | 00:11 | . 5 | 1.183302 | 1.339694 | 0.553121 | 00:20 | . 6 | 1.027278 | 1.148169 | 0.634904 | 00:20 | . 7 | 0.919856 | 1.031522 | 0.672866 | 00:20 | . 8 | 0.890848 | 0.910739 | 0.713885 | 00:20 | . 9 | 0.824205 | 0.932853 | 0.697580 | 00:20 | . 10 | 1.054473 | 1.329592 | 0.585987 | 00:20 | . 11 | 0.947696 | 1.136064 | 0.637452 | 00:20 | . 12 | 0.852863 | 0.820551 | 0.731210 | 00:20 | . 13 | 0.794559 | 1.009437 | 0.673631 | 00:20 | . 14 | 0.775261 | 0.844786 | 0.721529 | 00:20 | . 15 | 0.933353 | 1.198227 | 0.640000 | 00:20 | . 16 | 0.846583 | 0.898716 | 0.715669 | 00:19 | . 17 | 0.789335 | 0.781211 | 0.741656 | 00:20 | . 18 | 0.745516 | 1.174927 | 0.637962 | 00:19 | . 19 | 0.705972 | 0.786245 | 0.751847 | 00:20 | . Sparsity at the end of epoch 0: 0.00% Saving Weights at epoch 1 Sparsity at the end of epoch 1: 0.00% Sparsity at the end of epoch 2: 0.00% Sparsity at the end of epoch 3: 0.00% Sparsity at the end of epoch 4: 0.00% Resetting Weights to their epoch 1 values Sparsity at the end of epoch 5: 16.67% Sparsity at the end of epoch 6: 16.67% Sparsity at the end of epoch 7: 16.67% Sparsity at the end of epoch 8: 16.67% Sparsity at the end of epoch 9: 16.67% Resetting Weights to their epoch 1 values Sparsity at the end of epoch 10: 33.33% Sparsity at the end of epoch 11: 33.33% Sparsity at the end of epoch 12: 33.33% Sparsity at the end of epoch 13: 33.33% Sparsity at the end of epoch 14: 33.33% Resetting Weights to their epoch 1 values Sparsity at the end of epoch 15: 50.00% Sparsity at the end of epoch 16: 50.00% Sparsity at the end of epoch 17: 50.00% Sparsity at the end of epoch 18: 50.00% Sparsity at the end of epoch 19: 50.00% Final Sparsity: 50.00 . We can see here the benefits of rewinding, as the network has reached $75 %$ in $5$ epochs, which is better than plain LTH, but also way better than the original, dense model. . . Remark: The current methods return the winning ticket after it has been trained, i.e. $W_T odot m$ . If you would like to return the ticket re-initialized to its rewind epoch, i.e. the network $W_t odot m$, just pass the argument reset_end=True to the callback. . . It thus seem to be possible to train sparse networks, and that they even are able to overperform their dense counterpart ! I hope that this blog post gave you a better overview of what Lottery Tickets are and that you are now able to use this secret weapon in your projects. Go win yourself the initialization lottery ! 🎰 . . . If you notice any mistake or improvement that can be done, please contact me ! If you found that post useful, please consider citing it as: . @article{hubens2020fasterai, title = &quot;Winning the Lottery with fastai&quot;, author = &quot;Hubens, Nathan&quot;, journal = &quot;nathanhubens.github.io&quot;, year = &quot;2022&quot;, url = &quot;https://nathanhubens.github.io/posts/deep%20learning/2022/02/16/Lottery.html&quot; } . References . 1. Torsten Hoefler et al. Sparsity in Deep Learning: Pruning and growth for efficient inference and training in neural networks. JMLR, 2021↩ . | 2. Jonathan Frankle and Michael Carbin. The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks.ICLR, 2019↩ . | 3. Jonathan Frankle, Gintare Karolina Dziugaite, Daniel M Roy, and Michael Carbin. 2020. Linear Mode Connectivity and the Lottery Ticket Hypothesis. ICLR, 2020↩ . | .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2022/02/16/Lottery.html",
            "relUrl": "/deep%20learning/2022/02/16/Lottery.html",
            "date": " • Feb 16, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Which Pruning Schedule Should I Use?",
            "content": "Introduction . In a previous post, we spoke about Pruning Schedules. More specifically, we introduced the 2 most common ones: One-Shot Pruning and Iterative Pruning, but also, another interesting schedule: Automated Gradual Pruning1 . . From all of those, the most commonly used pruning schedule is the Iterative Pruning because of its simplicity. The process can be summarized as: . Train the network until convergence | Prune the network | Fine-tune it to recover lost performance | Repeat from step 2 until desired sparsity. | It thus consists of several cycles of pruning/fine-tuning, usually using a smaller learning rate than for the initial training. But is it really better than other schedules ? Also, could we possibly come up with a better schedule ? . Moreover, when using such a schedule, several questions remain open, for example: . Should we really wait that the network has converged before pruning ? | If we perform the fine-tuning step, should we wait that the network has recovered the lost performance before doing a new pruning step ? | How many cycles should we do ? | How should we chose the learning rate for fine-tuning? | . . In this post, we&#39;ll try to provide elements of answer to those questions. In particular, we will compare all the pruning schedules and introduce a new one. . We will use the Imagenette dataset in order to perform our experiments. All we need then is to import fastai 2 and the sparse module from fasterai 3 . from fastai.vision.all import * from fasterai.sparse.all import * . . . Common Schedules . We will first compare the results of the common schedules introduced earlier. To get a fair comparison, all the schedules will be compared on a fixed training budget, using the same hyperparameters. . . One-Shot Pruning . The One-Shot Pruning schedule is pretty simple. It consists of 3 phases: . Train the network | Prune a portion of the weights | Fine-Tune the remaining weights | Given that our training budget is fixed, we have to decide wether to put more budget in the initial training phase, i.e. step 1) or in the fine-tuning phase, i.e. step 3). We empirically find that training for $40 %$ of the training budget, and fine-tuning for the remaining time allows for the best results, which suggests that the fine-tuning step is slightly more important than the training one. This can be explained by the fact that, by performing the pruning too late in the training makes it difficult for the network to recover the lost performance as we use a small learning rate towards the end of training. . If we plot the sparsity of our model along the training, one-shot pruning thus looks like this: . We trained our model with $0 %$ sparsity for $40 %$ of our training budget, prune it, then fine-tune for the remaining time. To do this, all is needed is the fasterai SparsifyCallback. . learn = Learner(dls, resnet18(num_classes=dls.c), metrics=accuracy) sp_cb = SparsifyCallback(95, &#39;weight&#39;, &#39;local&#39;, large_final, one_shot, start_epoch=4) learn.fit(10, 1e-3, cbs=sp_cb) . Pruning of weight until a sparsity of 95% . epoch train_loss valid_loss accuracy time . 0 | 1.561453 | 1.426115 | 0.527643 | 00:11 | . 1 | 1.270037 | 1.601807 | 0.473121 | 00:11 | . 2 | 1.124796 | 1.406487 | 0.545987 | 00:11 | . 3 | 1.021256 | 1.357861 | 0.571465 | 00:11 | . 4 | 0.977683 | 0.965558 | 0.687643 | 00:17 | . 5 | 0.879473 | 0.840178 | 0.725860 | 00:17 | . 6 | 0.796095 | 0.793685 | 0.739873 | 00:17 | . 7 | 0.768487 | 0.825092 | 0.737325 | 00:17 | . 8 | 0.732183 | 0.865477 | 0.725605 | 00:17 | . 9 | 0.703469 | 0.756053 | 0.755159 | 00:17 | . Saving Weights at epoch 0 Sparsity at the end of epoch 0: 0.00% Sparsity at the end of epoch 1: 0.00% Sparsity at the end of epoch 2: 0.00% Sparsity at the end of epoch 3: 0.00% Sparsity at the end of epoch 4: 95.00% Sparsity at the end of epoch 5: 95.00% Sparsity at the end of epoch 6: 95.00% Sparsity at the end of epoch 7: 95.00% Sparsity at the end of epoch 8: 95.00% Sparsity at the end of epoch 9: 95.00% Final Sparsity: 95.00 . One-Shot Pruning is often seen as the simplest pruning schedule. We thus have the above results that we can use as a baseline. . . Iterative Pruning . As decribed above, the Iterative Pruning Schedule can be broken down as: . Train the network until convergence | Prune the network | Fine-tune it to recover lost performance | Repeat from step 2 until desired sparsity. | Iterative Pruning is slightly different from One-Shot. Here, the pruning doesn&#39;t happen in one-step but in several cycles, alternating phase of pruning and fine-tuning. We found that, given a fixed budget, allowing $20 %$ of the training budget for initial training provides best results. For simplicity, we use the same budget of fine-tuning for each fine-tuning phase. . learn = Learner(dls, resnet18(num_classes=dls.c), metrics=accuracy) sp_cb = SparsifyCallback(95, &#39;weight&#39;, &#39;local&#39;, large_final, iterative, start_epoch=2) learn.fit_one_cycle(10, 1e-3, cbs=sp_cb) . Pruning of weight until a sparsity of 95% . epoch train_loss valid_loss accuracy time . 0 | 1.652174 | 1.787058 | 0.414268 | 00:15 | . 1 | 1.388728 | 1.397470 | 0.530955 | 00:13 | . 2 | 1.156839 | 1.455710 | 0.572739 | 00:18 | . 3 | 1.033233 | 1.359484 | 0.570446 | 00:17 | . 4 | 0.918170 | 0.894611 | 0.712866 | 00:17 | . 5 | 0.750040 | 0.786598 | 0.753885 | 00:17 | . 6 | 0.684740 | 0.735729 | 0.764841 | 00:17 | . 7 | 1.275929 | 1.178440 | 0.606624 | 00:18 | . 8 | 1.106493 | 1.048619 | 0.661911 | 00:17 | . 9 | 1.055405 | 1.035571 | 0.668790 | 00:18 | . Saving Weights at epoch 0 Sparsity at the end of epoch 0: 0.00% Sparsity at the end of epoch 1: 0.00% Sparsity at the end of epoch 2: 31.67% Sparsity at the end of epoch 3: 31.67% Sparsity at the end of epoch 4: 63.33% Sparsity at the end of epoch 5: 63.33% Sparsity at the end of epoch 6: 63.33% Sparsity at the end of epoch 7: 95.00% Sparsity at the end of epoch 8: 95.00% Sparsity at the end of epoch 9: 95.00% Final Sparsity: 95.00 . As we can see, Iterative Pruning leads to worse results than plain One-Shot Pruning, how come? This is because we imposed a fixed training budget and that, as several works have reported, Iterative Pruning requires a significantly longer fine-tuning process in order to get a better performing pruned network 4. . . Automated Gradual Pruning (AGP) . The main problem of the previous schedules is the discontinuity that happens at each pruning step. Indeed, when the pruning is performed, the network sparsity suddenly increases by a lot, making it very difficult for the network to recover its previous performance. More recently, Automated Gradual Pruning was introduced, which allows to vary the pruning frequency, thus making the pruning process &quot;smoother&quot;. However, it still requires to set a starting point, which we found to be around $20 %$ of the training. . learn = Learner(dls, resnet18(num_classes=dls.c), metrics=accuracy) sp_cb = SparsifyCallback(95, &#39;weight&#39;, &#39;local&#39;, large_final, sched_agp, start_epoch=2) learn.fit_one_cycle(10, 1e-3, cbs=sp_cb) . Pruning of weight until a sparsity of 95% . epoch train_loss valid_loss accuracy time . 0 | 1.641825 | 1.530526 | 0.501911 | 00:12 | . 1 | 1.386651 | 1.331521 | 0.565350 | 00:12 | . 2 | 1.215227 | 1.174754 | 0.607898 | 00:17 | . 3 | 1.069576 | 1.253404 | 0.596433 | 00:17 | . 4 | 0.964384 | 1.204816 | 0.629045 | 00:17 | . 5 | 0.903077 | 0.989587 | 0.684331 | 00:17 | . 6 | 0.846415 | 0.961558 | 0.685605 | 00:17 | . 7 | 0.777686 | 0.757304 | 0.753631 | 00:17 | . 8 | 0.742017 | 0.719318 | 0.766624 | 00:17 | . 9 | 0.685183 | 0.702805 | 0.771465 | 00:17 | . Saving Weights at epoch 0 Sparsity at the end of epoch 0: 0.00% Sparsity at the end of epoch 1: 0.00% Sparsity at the end of epoch 2: 31.36% Sparsity at the end of epoch 3: 54.92% Sparsity at the end of epoch 4: 71.81% Sparsity at the end of epoch 5: 83.12% Sparsity at the end of epoch 6: 89.99% Sparsity at the end of epoch 7: 93.52% Sparsity at the end of epoch 8: 94.81% Sparsity at the end of epoch 9: 95.00% Final Sparsity: 95.00 . With AGP, we can see that we are able to outperform One-Shot Pruning. Indeed, the smoother pruning probably makes it easier for the network to accomodate from the increase of sparsity. . . . Other schedules . What other &quot;smooth&quot; schedule can we think about ? Fasterai let&#39;s you try the schedules available by default in fastai, so let&#39;s give them a shot! . Those default schedule are: . Annealing Linear | Annealing Exponential | Annealing Cosine | . . Linear Schedule . learn = Learner(dls, resnet18(num_classes=dls.c), metrics=accuracy) sp_cb = SparsifyCallback(95, &#39;weight&#39;, &#39;local&#39;, large_final, sched_lin) learn.fit_one_cycle(10, 1e-3, cbs=sp_cb) . Pruning of weight until a sparsity of 95% . epoch train_loss valid_loss accuracy time . 0 | 1.604190 | 1.709037 | 0.472102 | 00:17 | . 1 | 1.375103 | 1.457334 | 0.534522 | 00:17 | . 2 | 1.178370 | 1.318951 | 0.561019 | 00:17 | . 3 | 1.039873 | 1.149634 | 0.624713 | 00:17 | . 4 | 0.926598 | 1.011326 | 0.674650 | 00:17 | . 5 | 0.820038 | 0.889869 | 0.720764 | 00:17 | . 6 | 0.741654 | 0.782931 | 0.738089 | 00:17 | . 7 | 0.653089 | 0.791211 | 0.744204 | 00:17 | . 8 | 0.640457 | 0.852838 | 0.729427 | 00:18 | . 9 | 1.305882 | 2.434855 | 0.220892 | 00:17 | . Saving Weights at epoch 0 Sparsity at the end of epoch 0: 9.50% Sparsity at the end of epoch 1: 19.00% Sparsity at the end of epoch 2: 28.50% Sparsity at the end of epoch 3: 38.00% Sparsity at the end of epoch 4: 47.50% Sparsity at the end of epoch 5: 57.00% Sparsity at the end of epoch 6: 66.50% Sparsity at the end of epoch 7: 76.00% Sparsity at the end of epoch 8: 85.50% Sparsity at the end of epoch 9: 95.00% Final Sparsity: 95.00 . The linear schedule looks OK until the very last iteration. As we have seen for Iterative Pruning, the network needs a bit of fine-tuning after pruning some weights, which is not the case here as we continue pruning the weights until the very end, so the sparsity in the network never settles. . . Exponential Schedule . learn = Learner(dls, resnet18(num_classes=dls.c), metrics=accuracy) sp_cb = SparsifyCallback(95, &#39;weight&#39;, &#39;local&#39;, large_final, sched_exp, start_sparsity=0.0001) learn.fit_one_cycle(10, 1e-3, cbs=sp_cb) . Pruning of weight until a sparsity of 95% . epoch train_loss valid_loss accuracy time . 0 | 1.637005 | 1.904222 | 0.437962 | 00:17 | . 1 | 1.368260 | 2.153302 | 0.376561 | 00:17 | . 2 | 1.193901 | 1.408279 | 0.567898 | 00:17 | . 3 | 1.083588 | 1.378163 | 0.550318 | 00:17 | . 4 | 0.921528 | 1.076043 | 0.654013 | 00:17 | . 5 | 0.828063 | 1.027332 | 0.669554 | 00:17 | . 6 | 0.751379 | 0.730978 | 0.760255 | 00:17 | . 7 | 0.625477 | 0.683287 | 0.782166 | 00:18 | . 8 | 0.546839 | 0.601401 | 0.808408 | 00:17 | . 9 | 0.850577 | 2.636575 | 0.098344 | 00:17 | . Saving Weights at epoch 0 Sparsity at the end of epoch 0: 0.00% Sparsity at the end of epoch 1: 0.00% Sparsity at the end of epoch 2: 0.01% Sparsity at the end of epoch 3: 0.02% Sparsity at the end of epoch 4: 0.10% Sparsity at the end of epoch 5: 0.39% Sparsity at the end of epoch 6: 1.53% Sparsity at the end of epoch 7: 6.06% Sparsity at the end of epoch 8: 23.99% Sparsity at the end of epoch 9: 95.00% Final Sparsity: 95.00 . Exponential schedule provides even worse results. This was to be expected as the increase of sparsity mostly happen at the end of training (from $24 %$ to $95 %$ in the last epoch), giving the network even less time to recover. . . Cosine Schedule . learn = Learner(dls, resnet18(num_classes=dls.c), metrics=accuracy) sp_cb = SparsifyCallback(95, &#39;weight&#39;, &#39;local&#39;, large_final, sched_cos) learn.fit_one_cycle(10, 1e-3, cbs=sp_cb) . Pruning of weight until a sparsity of 95% . epoch train_loss valid_loss accuracy time . 0 | 1.669174 | 2.382740 | 0.333503 | 00:18 | . 1 | 1.357350 | 1.414894 | 0.556433 | 00:18 | . 2 | 1.162969 | 1.857623 | 0.497580 | 00:18 | . 3 | 1.023889 | 1.120237 | 0.635159 | 00:18 | . 4 | 0.913671 | 1.300077 | 0.585478 | 00:18 | . 5 | 0.828866 | 1.084937 | 0.663185 | 00:18 | . 6 | 0.754994 | 0.804495 | 0.742420 | 00:17 | . 7 | 0.708546 | 0.784795 | 0.745223 | 00:17 | . 8 | 0.762766 | 0.890425 | 0.712357 | 00:17 | . 9 | 1.133683 | 1.242696 | 0.591847 | 00:17 | . Saving Weights at epoch 0 Sparsity at the end of epoch 0: 2.32% Sparsity at the end of epoch 1: 9.07% Sparsity at the end of epoch 2: 19.58% Sparsity at the end of epoch 3: 32.82% Sparsity at the end of epoch 4: 47.50% Sparsity at the end of epoch 5: 62.18% Sparsity at the end of epoch 6: 75.42% Sparsity at the end of epoch 7: 85.93% Sparsity at the end of epoch 8: 92.68% Sparsity at the end of epoch 9: 95.00% Final Sparsity: 95.00 . Cosine Schedule is a bit better, but we can still see the drop in performance at the end, because the sparsity in the network never settles. . . So what can we do from here ? . . From what we have seen, Automated Gradual Pruning is the technique that works best so far. AGP possess a long &quot;tail&quot;, allowing the network to be fine-tuned with almost no increase in sparsity towards the end of pruning, which is definitely lacking from those default fastai schedules. . Can we modify previous schedules to have a similar behaviour ? What if we artificially add a tail to our cosine schedule ? . In fasterai, this can be done by passing the argument end_epoch, corresponding to the epoch we stop pruning. In this case, it means that we will have 3 entire epochs where the sparsity doesn&#39;t change, so the fine-tuning may be more efficient. . Pruning of weight until a sparsity of 95% . epoch train_loss valid_loss accuracy time . 0 | 1.668230 | 2.046625 | 0.390828 | 00:18 | . 1 | 1.352506 | 1.737922 | 0.458854 | 00:18 | . 2 | 1.175191 | 2.125888 | 0.474395 | 00:18 | . 3 | 1.032842 | 1.133045 | 0.644076 | 00:18 | . 4 | 0.984874 | 1.461341 | 0.530191 | 00:18 | . 5 | 0.926132 | 1.015559 | 0.656560 | 00:18 | . 6 | 0.902270 | 0.815804 | 0.730701 | 00:18 | . 7 | 0.727744 | 0.706084 | 0.771210 | 00:18 | . 8 | 0.682093 | 0.692142 | 0.776306 | 00:18 | . 9 | 0.660345 | 0.688686 | 0.777070 | 00:18 | . Saving Weights at epoch 0 Sparsity at the end of epoch 0: 4.70% Sparsity at the end of epoch 1: 17.88% Sparsity at the end of epoch 2: 36.93% Sparsity at the end of epoch 3: 58.07% Sparsity at the end of epoch 4: 77.12% Sparsity at the end of epoch 5: 90.30% Sparsity at the end of epoch 6: 95.00% Sparsity at the end of epoch 7: 95.00% Sparsity at the end of epoch 8: 95.00% Sparsity at the end of epoch 9: 95.00% Final Sparsity: 95.00 . As we can see now, this kind of schedule allows our network to reach similar performance than AGP. . . . Can we do better ? . It has been showed recently that the most critical phase in the training of a neural network happens during the very first iterations 5 and that applying regularization after that initial transient phase has little effect on the final performance of the network. 6 . As network pruning removes some weights, reducing the capacity of the network, it can be seen as a kind of regularization. One thus should apply pruning early in the training to take advantage of its regularization effects but must do so very carefully to not irremediably damage the network during this brittle period. . Can we create a scheduling that gets the best of both worlds, i.e. start pruning slowly right from the start and has a long fine-tuning at the end ? The cosine schedule with a tail seemed to be a good start but is a bit lacking some kind of customization. . Introducing One-Cycle Pruning . We thus introduce One-Cycle Pruning schedule which, as the name suggests, possess only a single cycle of pruning, happening all along the training. The expression of the sparsity along the training is given by: . $$ s_t = s_i + (s_f - s_i) cdot frac{1+e^{- alpha+ beta}}{1+e^{- alpha t + beta}} $$ with $s_t$, the level of sparsity at training step $t$, $s_i$ and $s_f$ respectively the initial and final level of sparsity. . This schedule can be customized by varying the slope of pruning (the $ alpha$ parameter) of the offset (the $ beta$ parameter), but we have found that good defaults values are respectively $14$ and $5$. . To use it with fasterai, we only need to create the corresponding function: . def sched_onecycle(start, end, pos, α=14, β=5): out = (1+np.exp(-α+β)) / (1 + (np.exp((-α*pos)+β))) return start + (end-start)*out . Then use it in the Callback: . learn = Learner(dls, resnet18(num_classes=dls.c), metrics=accuracy) sp_cb = SparsifyCallback(95, &#39;weight&#39;, &#39;local&#39;, large_final, sched_onecycle) learn.fit_one_cycle(10, 1e-3, cbs=sp_cb) . Pruning of weight until a sparsity of 95% . epoch train_loss valid_loss accuracy time . 0 | 1.629503 | 1.880378 | 0.441783 | 00:17 | . 1 | 1.369810 | 1.583246 | 0.484841 | 00:17 | . 2 | 1.192665 | 1.541420 | 0.520510 | 00:18 | . 3 | 1.069878 | 1.174934 | 0.625478 | 00:17 | . 4 | 1.043352 | 1.543538 | 0.500892 | 00:17 | . 5 | 0.947589 | 1.077303 | 0.638981 | 00:17 | . 6 | 0.842358 | 0.792739 | 0.739873 | 00:17 | . 7 | 0.729982 | 0.711569 | 0.774013 | 00:17 | . 8 | 0.656394 | 0.652494 | 0.788280 | 00:17 | . 9 | 0.624965 | 0.645904 | 0.793376 | 00:18 | . Saving Weights at epoch 0 Sparsity at the end of epoch 0: 2.53% Sparsity at the end of epoch 1: 9.48% Sparsity at the end of epoch 2: 29.46% Sparsity at the end of epoch 3: 61.34% Sparsity at the end of epoch 4: 83.69% Sparsity at the end of epoch 5: 91.94% Sparsity at the end of epoch 6: 94.24% Sparsity at the end of epoch 7: 94.82% Sparsity at the end of epoch 8: 94.96% Sparsity at the end of epoch 9: 95.00% Final Sparsity: 95.00 . As we can see, such a schedule allows our network to reach a higher performance given our training budget. . . . In this blog post, we experimented with a few pruning schedules and showed that, under a strict and fixed training budget, One-Cycle Pruning performs best. If the training budget doesn&#39;t matter, then Iterative Pruning might be a good default option . Feel free to also experiment and maybe come up with your own pruning schedule, that perfectly fits your task ! . . . . If you notice any mistake or improvement that can be done, please contact me ! If you found that post useful, please consider citing it as: . @article{hubens2021schedule, title = &quot;Which Pruning Schedule Should I Use ?&quot;, author = &quot;Hubens, Nathan&quot;, journal = &quot;nathanhubens.github.io&quot;, year = &quot;2021&quot;, url = &quot;https://nathanhubens.github.io/posts/deep%20learning/2021/06/15/OneCycle.html&quot; } . References . 1. Zhu, M. &amp; Gupta, S. (2017). To prune, or not to prune: exploring the efficacy of pruning for model compression. ICLR, 2018 ↩ . | 2. Howard J. and Gugger S., fastai: A Layered API for Deep Learning, 2020↩ . | 3. Hubens, N. (2020). Fasterai: Make smaller and faster networks with fastai↩ . | 4. Li H. , Kadav A., Durdanovic I., Samet H., and Peter Graf H., “Pruning filters forefficient convnets,”International Conference on Learning Representations, ICLR, 2017↩ . | 5. Frankle J., Schwab D., and Morcos A., “The early phase of neural network training,” in International Conference on Learning Representations, ICLR, 2020↩ . | 6. Golatkar A., Achille A., and Soatto S., “Time matters in regularizing deep networks: Weight decay and data augmentation affect early learning dynamics, matter little near convergence,” CoRR, vol. abs/1905.13277, 2019.↩ . | .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2021/06/15/OneCycle.html",
            "relUrl": "/deep%20learning/2021/06/15/OneCycle.html",
            "date": " • Jun 15, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "FasterAI",
            "content": ". The code is available here . . Introducing FasterAI . FasterAI is a project that I started to make my neural networks smaller and faster with the use of the fastai library. The techniques implemented here can easily be used with plain Pytorch but the idea was to express them in an abstract and easy-to-use manner (à la fastai). . In this article, we&#39;ll explain how to use FasterAI by going through an example use-case. . . Ready ? Let&#39;s dive in then ! . . Let&#39;s start with a bit of context for the purpose of the demonstration. Imagine that we want to deploy a VGG16 model on a mobile device that has limited storage capacity and that our task requires our model to run sufficiently fast. It is known that parameters and speed efficiency are not the strong points of VGG16 but let&#39;s see what we can do with it. . Let&#39;s first check the number of parameters and the inference time of VGG16. . learn = Learner(data, models.vgg16_bn(num_classes=10), metrics=[accuracy]) . So, VGG16 has 134 millions of parameters . Total parameters : 134,309,962 . And takes 4.03ms to perform inference on a single image. . 4.03 ms ± 18.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . Snap ! This is more than we can afford for deployment, ideally we would like our model to take only half of that...but should we give up ? Nope, there are actually a lot of techniques that we can use to help reducing the size and improve the speed of our models! Let&#39;s see how to apply them with FasterAI. . . We will first train our VGG16 model to have a baseline of what performance we should expect from it. . learn.fit_one_cycle(10, 1e-4) . epoch train_loss valid_loss accuracy time . 0 | 2.016354 | 1.778865 | 0.368917 | 01:31 | . 1 | 1.777570 | 1.508860 | 0.523567 | 01:31 | . 2 | 1.436139 | 1.421571 | 0.569172 | 01:32 | . 3 | 1.275864 | 1.118840 | 0.630064 | 01:31 | . 4 | 1.136620 | 0.994999 | 0.687898 | 01:31 | . 5 | 0.970474 | 0.824344 | 0.739618 | 01:31 | . 6 | 0.878756 | 0.764273 | 0.765605 | 01:32 | . 7 | 0.817084 | 0.710727 | 0.781911 | 01:31 | . 8 | 0.716041 | 0.625853 | 0.804841 | 01:31 | . 9 | 0.668815 | 0.605727 | 0.810955 | 01:31 | . So we would like our network to have comparable accuracy but fewer parameters and running faster... And the first technique that we will show how to use is called Knowledge Distillation . . . . Knowledge Distillation . Knowledge distillation is a simple yet very efficient way to train a model. It was introduced in 2006 by Caruana et al.1. The main idea behind is to use a small model (called the student) to approximate the function learned by a larger and high-performing model (called the teacher). This can be done by using the large model to pseudo-label the data. This idea has been used very recently to break the state-of-the-art accuracy on ImageNet2. . When we train our model for classification, we usually use a softmax as last layer. This softmax has the particularity to squish low value logits towards 0, and the highest logit towards 1. This has for effect to completely lose all the inter-class information, or what is sometimes called the dark knowledge. This is the information that is valuable and that we want to transfer from the teacher to the student. . To do so, we still use a regular classification loss but at the same time, we&#39;ll use another loss, computed between the softened logits of the teacher (our soft labels) and the softened logits of the student (our soft predictions). Those soft values are obtained when you use a soft-softmax, that avoids squishing the values at its output. Our implementation follows this paper3 and the basic principle of training is represented in the figure below: . . . To use Knowledge Distillation with FasterAI, you only need to use this callback when training your student model: . . KnowledgeDistillation(student:Learner, teacher:Learner) . You only need to give to the callback function your student learner and your teacher learner. Behind the scenes, FasterAI will take care of making your model train using knowledge distillation. . . The first thing to do is to find a teacher, which can be any model, that preferrably performs well. We will chose VGG19 for our demonstration. To make sure it performs better than our VGG16 model, let&#39;s start from a pretrained version. . teacher = cnn_learner(data, models.vgg19_bn, metrics=[accuracy]) teacher.fit_one_cycle(3, 1e-4) . epoch train_loss valid_loss accuracy time . 0 | 0.249884 | 0.088749 | 0.972739 | 01:02 | . 1 | 0.201829 | 0.087495 | 0.974268 | 01:02 | . 2 | 0.261882 | 0.082631 | 0.974013 | 01:01 | . Our teacher has 97.4% of accuracy which is pretty good, it is ready to take a student under its wing. So let&#39;s create our student model and train it with the Knowledge Distillation callback: . student = Learner(data, models.vgg16_bn(num_classes=10), metrics=[accuracy]) student.fit_one_cycle(10, 1e-4, callbacks=[KnowledgeDistillation(student, teacher)]) . epoch train_loss valid_loss accuracy time . 0 | 2.323744 | 2.102873 | 0.410955 | 02:16 | . 1 | 2.099557 | 2.441147 | 0.571465 | 02:16 | . 2 | 1.829197 | 2.215419 | 0.607643 | 02:16 | . 3 | 1.617705 | 1.683477 | 0.667006 | 02:16 | . 4 | 1.364808 | 1.366435 | 0.713376 | 02:16 | . 5 | 1.257906 | 0.985063 | 0.788025 | 02:16 | . 6 | 1.087404 | 0.877424 | 0.801019 | 02:17 | . 7 | 0.949960 | 0.777630 | 0.822166 | 02:16 | . 8 | 0.868683 | 0.733206 | 0.837707 | 02:17 | . 9 | 0.756630 | 0.707806 | 0.843057 | 02:16 | . And we can see that indeed, the knowledge of the teacher was useful for the student, as it is clearly overperforming the vanilla VGG16. . Ok, so now we are able to get more from a given model which is kind of cool ! With some experimentations we could come up with a model smaller than VGG16 but able to reach the same performance as our baseline! You can try to find it by yourself later, but for now let&#39;s continue with the next technique ! . . . . Sparsifying . Now that we have a student model that is performing better than our baseline, we have some room to compress it. And we&#39;ll start by making the network sparse. As explained in a previous article, there are many ways leading to a sparse network. . . . Note: Usually, the process of making a network sparse is called Pruning. I prefer using the term Pruning when parameters are actually removed from the network, which we will do in the next section. . . . . By default, FasterAI uses the Automated Gradual Pruning paradigm as it removes parameters as the model trains and doesn&#39;t require to pretrain the model, so it is usually much faster. In FasterAI, this is also managed by using a callback, that will replace the least important parameters of your model by zeroes during the training. The callback has a wide variety of parameters to tune your Sparsifying operation, let&#39;s take a look at them: . . SparsifyCallback(learn, sparsity, granularity, method, criteria, sched_func) . sparsity: the percentage of sparsity that you want in your network | granularity: on what granularity you want the sparsification to be operated (currently supported: weight, filter) | method: either local or global, will affect the selection of parameters to be choosen in each layer independently (local) or on the whole network (global). | criteria: the criteria used to select which parameters to remove (currently supported: l1, taylor) | sched_func: which schedule you want to follow for the sparsification (currently supported: any scheduling function of fastai, i.e annealing_linear, annealing_cos, ... and annealing_gradual, the schedule proposed by Zhu &amp; Gupta4, represented in Figure below) | . . Although I found that Automated Gradual Pruning usually works best, you may want to use the other paradigms. They can easily be achieved by doing: . One-Shot Pruning . sparsifier = Sparsifier(granularity, method, criteria) new_model = sparsifier.prune(learn.model, sparsity) . To perform One-Shot Pruning, you can simply prune your model to the desired sparsity. This is probably highly suboptimal as removing parameters will shake up the model and hurt it quite a bit. . . Iterative Pruning . new_model = sparsifier.prune(learn.model, sparsity) learn = Learner(data, new_model) learn.fit(num_epochs, lr, callbacks=[SparsifyCallback(learn, sparsity, granularity, method, criteria, sched_func=annealing_no)]) sparsity += increase_value # REPEAT . To perform Iterative Pruning, we first need to train our model, then perform several iterations of pruning and fine-tuning until desired sparsity. Fine-tuning has to be done with SparsifyCallback and the annealing_no schedule to ensure our zero-weights don&#39;t get updated. . . But let&#39;s come back to our example! . Here, we will make our network 40% sparse, and remove entire filters, selected locally and based on L1 norm. We will train with a learning rate a bit smaller to be gentle with our network because it has already been trained. The scheduling selected is cosinusoidal, so the pruning starts and ends quite slowly. . student.fit(10, 1e-5, callbacks=[SparsifyCallback(student, sparsity=40, granularity=&#39;filter&#39;, method=&#39;local&#39;, criteria=&#39;l1&#39;, sched_func=annealing_cos)]) . Pruning of filter until a sparsity of 40% . epoch train_loss valid_loss accuracy time . 0 | 0.584072 | 0.532074 | 0.838471 | 01:34 | . 1 | 0.583805 | 0.499353 | 0.844586 | 01:34 | . 2 | 0.599410 | 0.527805 | 0.836433 | 01:34 | . 3 | 0.610081 | 0.544566 | 0.828025 | 01:35 | . 4 | 0.625637 | 0.543279 | 0.829809 | 01:34 | . 5 | 0.628777 | 0.563051 | 0.819618 | 01:34 | . 6 | 0.688617 | 0.617627 | 0.800000 | 01:34 | . 7 | 0.691044 | 0.629927 | 0.801019 | 01:34 | . 8 | 0.669935 | 0.576220 | 0.814013 | 01:33 | . 9 | 0.682428 | 0.562718 | 0.823949 | 01:34 | . Sparsity at epoch 0: 0.98% Sparsity at epoch 1: 3.83% Sparsity at epoch 2: 8.25% Sparsity at epoch 3: 13.83% Sparsity at epoch 4: 20.01% Sparsity at epoch 5: 26.19% Sparsity at epoch 6: 31.76% Sparsity at epoch 7: 36.19% Sparsity at epoch 8: 39.02% Sparsity at epoch 9: 40.00% Final Sparsity: 40.00 . Our network now has 40% of its filters composed entirely of zeroes, at the cost of 2% of accuracy. Obviously, choosing a higher sparsity, makes it more difficult for the network to keep a similar accuracy. Other parameters can also widely change the behaviour of our sparsification process. For example choosing a more fine-grained sparsity usually leads to better results but is then more difficult to take advantage of in terms of speed. . We can double-check that our model has indeed been pruned by 40% of its parameters. . Sparsity in Conv2d 2: 39.06% Sparsity in Conv2d 5: 39.06% Sparsity in Conv2d 9: 39.84% Sparsity in Conv2d 12: 39.84% Sparsity in Conv2d 16: 39.84% Sparsity in Conv2d 19: 39.84% Sparsity in Conv2d 22: 39.84% Sparsity in Conv2d 26: 39.84% Sparsity in Conv2d 29: 39.84% Sparsity in Conv2d 32: 39.84% Sparsity in Conv2d 36: 39.84% Sparsity in Conv2d 39: 39.84% Sparsity in Conv2d 42: 39.84% . We don&#39;t have exactly 40% because, as we removed complete filters, we don&#39;t necesserally have a round number. . . Let&#39;s now see how much we gained in terms of speed. Because we removed 40% of convolution filters, we should expect crazy speed-up right ? . 4.02 ms ± 5.77 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . Well actually, no. We didn&#39;t remove any parameters, we just replaced some by zeroes, remember? The amount of parameters is still the same: . Total parameters : 134,309,962 . Which leads us to the next section. . . . . Pruning . . Important: This is currently only supported for fully-feedforward models such as VGG-like models as more complex architectures require increasingly difficult and usually model-dependant implementations. . . Why don&#39;t we see any acceleration even though we removed half of the parameters? That&#39;s because natively, our GPU does not know that our matrices are sparse and thus isn&#39;t able to accelerate the computation. The easiest work around, is to physically remove the parameters we zeroed-out. But this operation requires to change the architecture of the network. . This pruning only works if we have zeroed-out entire filters beforehand as it is the only case where you can change the architecture accordingly. Hopefully, sparse computations will soon be available on common deep learning librairies so this section will become useless in the future, but for the moment, it is the best solution I could come up with 🤷 . . Here is what it looks like with fasterai: . . pruner = Pruner() pruned_model = pruner.prune_model(learn.model) . You just need to pass the model whose filters has previously been sparsified and FasterAI will take care of removing them. . . Note: This operation should be lossless as it only removes filters that already do not participate in the network anymore. . . So in the case of our example, it gives: . pruner = Pruner() pruned_model = pruner.prune_model(student.model) . Let&#39;s now see what our model is capable of now: . Total parameters : 83,975,344 . And in terms of speed: . 2.44 ms ± 3.51 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . . Yay ! Now we can talk ! Let&#39;s just double check that our accuracy is unchanged and that we didn&#39;t mess up somewhere: . [0.5641388, tensor(0.8229)] . . And there is actually more that we can do ! Let&#39;s keep going ! . . . . Batch Normalization Folding . Batch Normalization Folding is a really easy to implement and straightforward idea. The gist is that batch normalization is nothing more than a normalization of the input data at each layer. Moreover, at inference time, the batch statistics used for this normalization are fixed. We can thus incorporate the normalization process directly in the convolution by changing its weights and completely remove the batch normalization layers, which is a gain both in terms of parameters and in terms of computations. For a more in-depth explaination, see my previous post. . This is how to use it with FasterAI: . . bn_folder = BN_Folder() bn_folder.fold(learn.model)) . Again, you only need to pass your model and FasterAI takes care of the rest. For models built using the nn.Sequential, you don&#39;t need to change anything. For others, if you want to see speedup and compression, you actually need to subclass your model to remove the batch norm from the parameters and from the forward method of your network. . . Note: This operation should also be lossless as it redefines the convolution to take batch norm into account and is thus equivalent. . . Let&#39;s do this with our model ! . folded_model = bn_folding_model(pruned_learner.model) . The parameters drop is generally not that significant, especially in a network such as VGG where almost all parameters are contained in the FC layers but, hey, any gain is good to take. . Total parameters : 83,970,260 . . Now that we removed the batch normalization layers, we should again see a speedup. . 2.27 ms ± 1.22 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . Again, let&#39;s double check that we didn&#39;t mess up somewhere: . [0.5641388, tensor(0.8229)] . . And we&#39;re still not done yet ! As we know for VGG16, most of the parameters are comprised in the fully-connected layers so there should be something that we can do about it, right ? . . . . FC Layers Factorization . We can indeed, factorize our big fully-connected layers and replace them by an approximation of two smaller layers. The idea is to make an SVD decomposition of the weight matrix, which will express the original matrix in a product of 3 matrices: $U Sigma V^T$. With $ Sigma$ being a diagonal matrix with non-negative values along its diagonal (the singular values). We then define a value $k$ of singular values to keep and modify matrices $U$ and $V^T$ accordingly. The resulting will be an approximation of the initial matrix. . . In FasterAI, to decompose the fully-connected layers of your model, here is what you need to do: . . FCD = FCDecomposer() decomposed_model = FCD.decompose(model, percent_removed) . The percent_removed corresponds to the percentage of singular values removed (k value above). . . Note: This time, the decomposition is not exact, so we expect a drop in performance afterwards and further retraining will be needed. . . Which gives with our example, if we only want to keep half of them: . fc_decomposer = FCDecomposer() decomposed_model = fc_decomposer.decompose(folded_model, percent_removed=0.5) . How many parameters do we have now ? . Total parameters : 61,430,022 . And how much time did we gain ? . 2.11 ms ± 462 ns per loop (mean ± std. dev. of 7 runs, 100 loops each) . . However, this technique is an approximation so it is not lossless, so we should retrain our network a bit to recover its performance. . final_learner = Learner(data, decomposed_model, metrics=[accuracy]) final_learner.fit_one_cycle(5, 1e-5) . epoch train_loss valid_loss accuracy time . 0 | 0.795416 | 0.759886 | 0.772994 | 00:51 | . 1 | 0.752566 | 0.701141 | 0.794395 | 00:52 | . 2 | 0.700373 | 0.650178 | 0.804841 | 00:51 | . 3 | 0.604264 | 0.606801 | 0.821656 | 00:51 | . 4 | 0.545705 | 0.592318 | 0.823185 | 00:52 | . This operation is usually less useful for more recent architectures as they usually do not have that many parameters in their fully-connected layers. . . . . So to recap, we saw in this article how to use fasterai to: . Make a student model learn from a teacher model (Knowledge Distillation) | Make our network sparse (Sparsifying) | Optionnaly physically remove the zero-filters (Pruning) | Remove the batch norm layers (Batch Normalization Folding) | Approximate our big fully-connected layers by smaller ones (Fully-Connected Layers Factorization) | . And we saw that by applying those, we could reduce our VGG16 model from 134 million of parameters down to 61 million, and also speed-up the inference from 4.03ms to 2.11ms without any drop in accuracy (even a slight increase actually) compared to the baseline. . Of course, those techniques can be used in conjunction with quantization or mixed-precision training, which are already available in Pytorch for even more compression and speedup. . . . Note: Please keep in mind that the techniques presented above are not magic 🧙‍♂️, so do not expect to see a 200% speedup and compression everytime. What you can achieve highly depend on the architecture that you are using (some are already speed/parameter efficient by design) or the task it is doing (some datasets are so easy that you can remove almost all your network without seeing a drop in performance) . . That&#39;s all! Thank you for reading, I hope that you&#39;ll like FasterAI. I do not claim that it is perfect, you&#39;ll probably find a lot of bugs. If you do, just please tell me, so I can try to solve them 😌 . . . . If you notice any mistake or improvement that can be done, please contact me ! If you found that post useful, please consider citing it as: . @article{hubens2020fasterai, title = &quot;FasterAI&quot;, author = &quot;Hubens, Nathan&quot;, journal = &quot;nathanhubens.github.io&quot;, year = &quot;2020&quot;, url = &quot;https://nathanhubens.github.io/posts/deep%20learning/2020/08/17/FasterAI.html&quot; } . References . 1. Cristian Buciluǎ, Rich Caruana, and Alexandru Niculescu-Mizil. Model compression. In Proceedings of the 12th ACM SIGKDD international conference on Knowledge discovery and data mining, 2006↩ . | 2. Qizhe Xie, Minh-Thang Luong, Eduard Hovy, Quoc V. Le: Self-training with Noisy Student improves ImageNet classification. Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), 2020↩ . | 3. H. Li, &quot;Exploring knowledge distillation of Deep neural nets for efficient hardware solutions,&quot; CS230 Report, 2018↩ . | 4. Zhu, M. &amp; Gupta, S. (2017). To prune, or not to prune: exploring the efficacy of pruning for model compression. ICLR, 2018 ↩ . | .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2020/08/17/FasterAI.html",
            "relUrl": "/deep%20learning/2020/08/17/FasterAI.html",
            "date": " • Aug 17, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Neural Network Pruning",
            "content": "The curse of racing for high performance . While deep learning models are getting better in terms of performance, they also tend to get bigger and more expensive to compute. Until recently, it can seem that state-of-the-art models were achieved by using the good ol&#39; “Stack more layers !” property. Indeed, if you take a look at the history of state-of-the-art models on ImageNet, you will notice that each year, the new best results were achieved by using a deeper network. . It seems that we are obsessed with getting the best results as possible, leading to models that can involve hundreds of millions of parameters ! But what&#39;s the point of having a top-tier performing network if we cannot use it? . . There has to be a better way to solve our tasks... . After all, as the philosopher William of Occam argued in his principle named after him, the Occam&#39;s Razor: . “Pluralitas non est ponenda sine necessitate.” . Or in other words: . “Simpler solutions should be favored over more complex ones.” . One of the ways to do so is to use a more parameter efficient architecture. There is a very active research going on in that field, and we can state some notable architectures that are competitive with their parameter-heavy equivalents (SqueezeNet1, MobileNet2, Xception3, EfficientNet4,...). . . Do we really need a sledgehammer to crack a nut ? . What if I told you that you can still use your favorite architecture, but in a more efficient way ? After all, neural networks are meant to be used either on resource-constrained environments (mobile phones, autonomous cars, drones, ...) or to run on servers, so in both case, any gain in computation or memory storage would be beneficial. . Recently, there has been a very interesting paper by Frankle and Carbin5, where they introduce the lottery ticket hypothesis. This hypothesis states that, in a network, only a subset of the parameters is needed to achieve an optimal performance. The whole difficulty is then to find that particular subnetwork; the authors used a pruning technique consisting of pruning the trained model, then “rewinding” the initialization of remaining weights to their original initialization. Only that subnetwork, with that specific set of initialized weights is able to achieve the same level of accuracy as the entire network. . This discovery has huge implications, as it would imply that the only advantage of using parameter-heavy networks is to provide more initialization configuration and thus, more chance to get those “winning tickets”. . . Pruning . The inspiration behind neural network pruning is taken from how our own brain evolves during our life. Indeed, between our birth and adulthood, the amount of synapses (the structures that allows the neurons to transmit an electrical or chemical signal to another neuron) greatly varies. Our brain experience a large amount of growth during infancy, then basically follows a “use it or lose it” process. It results in a synaptic pruning which will remove any synapse that is not needed, in order to reach an optimal amount depending on our needs. . . In the case of neural networks, the principle of pruning is to remove network connections that are considered unimportant to keep the network performance unchanged. Pruning is actually a quite old idea (like most ideas of deep learning) but that is an active field of research nowadays. . It dates back to 1990s namely, with most popular work at that time being Optimal Brain Damage 6 and Optimal Brain Surgeon 7. Pruning has been popularized by Han et al. 8 with their 2015 paper. . . Pruning thus consists of inducing sparsity in the weights of the network. . “Every block of stone has a statue inside it and it is the task of the sculptor to discover it.” - Michelangelo . As Michelangelo and his blocks of stone, we will carve our neural networks to bring their beauty out of them, or until we make them as sparse as possible while preserving their original performance. . . Granularity . Neural network pruning can come in many fashion, represented in the image below: . . You can either be very precise and remove each weight independently or remove bigger chunks at a time. The more fine-grained (or unstructured) the pruning, the more precise the process will be, but the more difficult it will be to get any acceleration. On the other hand, removing bigger chunks at a time (structured pruning) will be less accurate, but will make life easier for any sparse matrix computation libraries. So granularity of pruning will be a trade-off between precision and acceleration. . . I guess it&#39;s a matter of preference, are you more a cubist or high renaissance deep learning artist ? . Apart from the granularity of pruning, you also have to choose when you will remove the weights. . . Scheduling . The timing and scheduling that you will adopt to prune your network will highly impact its final performance. . The three most commonly used schedulings are: . One-shot Pruning | Iterative Pruning | Automated Gradual Pruning | . The most basic idea is to start from a trained model, prune it to the desired sparsity, then optionally fine-tune the network to accommodate from the removal of some of its parameters. This technique is known as One-shot Pruning. However, a simple change in that technique is able to provide way better results. The idea is simply to perform the pruning phase over several steps, all followed by some fine-tuning. That technique is called Iterative Pruning and, while leading to better results, can sometimes be very time-consuming and computationally intensive, especially if the number of parameters removed at each iteration is low. There has also been some research9 in incorporating weight pruning directly inside of the training step, periodically removing the weights. This technique is called Automated Gradual Pruning. . . . . In the case of Automated Gradual Pruning, the schedule proposed by the authors is the following: . . This schedule leads to an important pruning early in the training, then slowly decreasing as the training progresses. . . Criteria . Now that we know how and when to remove our parameters, we have to know which ones to choose. . There exist many ways to evaluate weights importance, but the two most common ways are: . Weight Magnitude Pruning | Gradient Magnitude Pruning | . While being extremely simple, weight magnitude pruning has been found to be very effective. It simply consists of computing the $L1$-norm, i.e $ sum_{i} left|x_{i} right|$, of the weights (or group/kernel/filter depending on the granularity), and to remove the ones with the lowest values. In the case of gradient magnitude pruning, the only change is that we will multiply our weights by their corresponding gradients before computing the $L1$-norm on the result. . Those criteria can be evaluated locally, i.e. each channel is pruned until the desired sparsity is reached, resulting in equally sparse layers, or globally, i.e. we evaluate the weights over the whole network, resulting in a sparse network, but with layers having different sparsity values. . . Evaluation . In order to report how well a pruning technique is doing, you need metrics to evaluate it. . To avoid any ambiguity in the metrics used, Davis Blalock and Jose Javier Gonzalez Ortiz10 have proposed a library to unify the way we report metrics. More specifically, they propose to report: . Compression Ratio, which should be computed as: Compression Ratio = total_params/nonzero_params, with total_params being the original number of parameters in the network and nonzero_params the number of non-zero weights after pruning. . | Theoretical Speedup, which should be computed as: Speedup = total_flops/nonzero_flops, with total_flops being the amount of FLOPs in the original model and nonzero_flops the amount of FLOPs of the remaining non-zero weights. . | . It is important to report both metrics as the speedup greatly depends on where in the network the pruning is performed. Indeed, for a same compression ratio, two similar architectures can have widely different speedup values. This is because the FLOPs of the convolution operation highly depend on the size of their input dimension, which varies along the network. Most of parameters are usually contained towards the end of the network while most of the computation is performed in early layers, reason why early downsampling is widely used. . The graph below show how the number of parameters and FLOPs evolve in the VGG16 network: . . What it shows is that, the last 3 layers hold $48 %$ of the parameters while being only responsible of $9 %$ of the total FLOPs in the network. For that reason, in order to see the same speedup improvement, you will need to remove a lot more parameters in late layers than you would need in early layers. . Another problem remaining is that the reported speedup is a theoretical value. It means that you&#39;ll never observe such a speedup in reality, especially because common deep learning libraries do not support acceleration for sparse matrices, or that it requires dedicated hardware. The easiest way to make sure that you will get an inference speed improvement is to physically remove the weights (can only be done for entire filters 11), you don&#39;t need to take care of sparse matrix computations if you don&#39;t have the matrix anymore! The way to perform that operation for a layer $i$ is the following: . . As you remove a whole filter, it&#39;s not really introducing sparsity in the network as you now change a hyperparameter (number of filters in a layer). Moreover, if you decide to prune a single filter in layer $i$, it means that the corresponding feature map won&#39;t exist anymore. Thus, in the layer $i+1$, the kernels corresponding to the deleted feature maps have to be removed. So, pruning a filter saves parameters and computations both in the current layer and in the following one! . . That&#39;s all! Thank you for reading, I hope that you found this little tour over neural network pruning interesting and, more importantly, useful. . . . . If you notice any mistake or improvement that can be done, please contact me ! If you found that post useful, please consider citing it as: . @article{hubens2020pruning, title = &quot;Neural Network Pruning&quot;, author = &quot;Hubens, Nathan&quot;, journal = &quot;nathanhubens.github.io&quot;, year = &quot;2020&quot;, url = &quot;https://nathanhubens.github.io/posts/deep%20learning/2020/05/22/pruning.html&quot; } . . References . 1. Howard A. et al., SqueezeNet: AlexNet-level accuracy with 50x fewer parameters and &lt;1MB model size. ICLR, 2017↩ . | 2. Forrest N. Iandola et al., MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications. CoRR, abs/1704.04861, 2017↩ . | 3. Chollet F., Xception: Deep Learning with Depthwise Separable Convolutions. CVPR, 2017↩ . | 4. Mingxing T. and Quoc V. Le, EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks. ICML, 2019↩ . | 5. Frankle, J. &amp; Carbin, M., The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks. ICLR, 2019↩ . | 6. LeCun Y. and Denker J. and Solla S., Optimal Brain Damage, NeurIPS, 1990↩ . | 7. Hassibi, Babak and David G. Stork and Wolff, Gregory, Optimal Brain Surgeon: Extensions and performance comparisons, NeurIPS, 1993↩ . | 8. Han S. et al., Learning both Weights and Connections for Efficient Neural Networks, NeurIPS, 2015↩ . | 9. Zhu, M. &amp; Gupta, S. To prune, or not to prune: exploring the efficacy of pruning for model compression. ICLR, 2018↩ . | 10. Blalock D.,Gonzalez Ortiz J.,Frankle J., and Guttag J., What is the state of neural network pruning?. MLSys, 2020↩ . | 11. Hao Li et al., Pruning Filters for Efficient ConvNets, ICLR, 2017↩ . | .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2020/05/22/pruning.html",
            "relUrl": "/deep%20learning/2020/05/22/pruning.html",
            "date": " • May 22, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Speed-up inference with Batch Normalization Folding",
            "content": "Introduction . Batch Normalization 1 2 is a technique which takes care of normalizing the input of each layer to make the training process faster and more stable. In practice, it is an extra layer that we generally add after the computation layer and before the non-linearity. . It consists of 2 steps: . Normalize the batch by first subtracting its mean $ mu$, then dividing it by its standard deviation $ sigma$. | Further scale by a factor $ gamma$ and shift by a factor $ beta$. Those are the parameters of the batch normalization layer, required in case of the network not needing the data to have a mean of 0 and a standard deviation of 1. | $$ Large begin{aligned} &amp; mu_{ mathcal{B}} leftarrow frac{1}{m} sum_{i=1}^{m} x_{i} &amp; sigma_{ mathcal{B}}^{2} leftarrow frac{1}{m} sum_{i=1}^{m} left(x_{i}- mu_{ mathcal{B}} right)^{2} &amp; widehat{x}_{i} leftarrow frac{x_{i}- mu_{ mathcal{B}}}{ sqrt{ sigma_{ mathcal{B}}^{2}+ epsilon}} &amp;y_{i} leftarrow gamma widehat{x}_{i}+ beta equiv mathrm{BN}_{ gamma, beta} left(x_{i} right) end{aligned} $$ Due to its efficiency for training neural networks, batch normalization is now widely used. But how useful is it at inference time? . Once the training has ended, each batch normalization layer possesses a specific set of $ gamma$ and $ beta$, but also $ mu$ and $ sigma$, the latter being computed using an exponentially weighted average during training. It means that during inference, the batch normalization acts as a simple linear transformation of what comes out of the previous layer, often a convolution. . As a convolution is also a linear transformation, it also means that both operations can be merged into a single linear transformation! . This would remove some unnecessary parameters but also reduce the number of operations to be performed at inference time. . . . How to do that in practice? . With a little bit of math, we can easily rearrange the terms of the convolution to take the batch normalization into account. . As a little reminder, the convolution operation followed by the batch normalization operation can be expressed, for an input $x$, as: . $$ Large begin{aligned} z &amp;=W * x+b text { out } &amp;= gamma cdot frac{z- mu}{ sqrt{ sigma^{2}+ epsilon}}+ beta end{aligned} $$So, if we re-arrange the $W$ and $b$ of the convolution to take the parameters of the batch normalization into account, as such: . $$ Large begin{aligned} w_{ text {fold }} &amp;= gamma cdot frac{W}{ sqrt{ sigma^{2}+ epsilon}} b_{ text {fold }} &amp;= gamma cdot frac{b- mu}{ sqrt{ sigma^{2}+ epsilon}}+ beta end{aligned} $$We can remove the batch normalization layer and still have the same results! . . Note: Usually, you don’t have a bias in a layer preceding a batch normalization layer. It is useless and a waste of parameters as any constant will be canceled out by the batch normalization. . . . How efficient is it? . We will try for 2 common architectures: . VGG16 with batch norm | ResNet50 | Just for the demonstration, we will use ImageNette dataset and PyTorch. Both networks will be trained for 5 epochs and what changes in terms of parameter number and inference time. . . VGG16 . Let’s start by training VGG16 for 5 epochs (the final accuracy doesn’t matter): . epoch train_loss valid_loss accuracy time . 0 | 1.985012 | 3.945934 | 0.226497 | 00:31 | . 1 | 1.868819 | 1.620619 | 0.472611 | 00:31 | . 2 | 1.574975 | 1.295385 | 0.576815 | 00:31 | . 3 | 1.305211 | 1.161460 | 0.617325 | 00:32 | . 4 | 1.072395 | 0.955824 | 0.684076 | 00:32 | . Then show its number of parameters: . Total parameters : 134,309,962 . We can get the initial inference time by using the %%timeit magic command: . %%timeit model(x[0][None].cuda()) . 2.77 ms ± 1.65 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . So now if we apply batch normalization folding, we have: . Total parameters : 134,301,514 . And: . %%timeit folded_model(x[0][None].cuda()) . 2.41 ms ± 2.49 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . So 8448 parameters removed and even better, almost 0.4 ms faster inference! Most importantly, this is completely lossless, there is absolutely no change in terms of performance: . folded_learner.validate() . [0.9558241, tensor(0.6841)] . Let’s see how it behaves in the case of Resnet50! . . Resnet50 . Same, we start by training it for 5 epochs: . epoch train_loss valid_loss accuracy time . 0 | 2.076416 | 2.491038 | 0.246624 | 00:20 | . 1 | 1.696750 | 1.517581 | 0.489427 | 00:19 | . 2 | 1.313028 | 1.206347 | 0.606115 | 00:20 | . 3 | 1.057600 | 0.890211 | 0.716943 | 00:21 | . 4 | 0.828224 | 0.793130 | 0.740892 | 00:19 | . The initial amount of parameters is: . Total parameters : 23,528,522 . And inference time is: . %%timeit model(x[0][None].cuda()) . 6.17 ms ± 13.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . After using batch normalization folding, we have: . Total parameters : 23,501,962 . And: . %%timeit final_model(x[0][None].cuda()) . 4.47 ms ± 8.97 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . So now, we have 26,560 parameters removed and even more impressive, an inference time reduce by 1.7ms! And still without any drop in performance. . final_learner.validate() . [0.7931296, tensor(0.7409)] . . So if we can reduce the inference time and the number of parameters of our models without enduring any drop in performance, why shouldn’t we always do it? . . I hope that this blog post helped you! Feel free to give me feedback or ask me questions is something is not clear enough. . Code available at this address! . . . References . 1. The Batch Normalization paper↩ . | 2. DeepLearning.ai Batch Normalization Lesson↩ . | .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2020/04/20/BN.html",
            "relUrl": "/deep%20learning/2020/04/20/BN.html",
            "date": " • Apr 20, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Build a simple Image Retrieval System with an Autoencoder",
            "content": "Image retrieval is a very active and fast-advancing field of research area in the past decade. The most well-known systems being the Google Image Search and Pinterest Visual Pin Search. In this article, we will learn to build a very simple image retrieval system using a special type of Neural Network, called an autoencoder. The way we are going to proceed is in an unsupervised way, i.e without looking at the image labels. Indeed, we will retrieve images only by using their visual contents (textures, shapes,…). This type of image retrieval is called content-based image retrieval (CBIR), opposed to keywords or text-based image retrieval. For this article, we will use images of handwritten digits, the MNIST dataset and the Keras deep-learning framework. . . Autoencoders . Briefly, autoencoders are neural networks that aims to copy their inputs to their outputs. They work by compressing the input into a latent-space representation, and then reconstructing the output from this representation.This kind of network is composed of two parts : . Encoder: This is the part of the network that compresses the input into a latent-space representation. It can be represented by an encoding function $h=f(x)$. . | Decoder: This part aims to reconstruct the input from the latent space representation. It can be represented by a decoding function $r=g(h)$. . | . . If you want to learn more about autoencoders, I suggest you to read my previous blog post. . . This latent representation, or code, is what will interest us here as it is the way the neural network as found to compress the visual content about each image. It means that all of similar images will be encoded (hopefully) in a similar way. There are several types of autoencoders but since we are dealing with images, the most efficient is to use a convolutional autoencoder, that uses convolution layers to encode and decode images. . x = Input(shape=(28, 28, 1)) # Encoder conv1_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) # Decoder conv2_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . The first step is thus to train our autoencoder with our training set, to make it learn the way to encode our images into a latent-space representation. Once the training as been performed, we only need the encoding part of the network. . encoder = Model(inputs=autoencoder.input, outputs=autoencoder.get_layer(&#39;encoder&#39;).output) . This encoder can now be used to encode our query image. . . The same encoding must be done on our searching database, where we want to find similar images to the query image. We can then compare the query code to the database code and try to find the closest ones. To perform this comparison, we will use the nearest-neighbors technique. . Nearest-neighbors . The way we are going to retrieve the closest codes is by performing the nearest-neighbors algorithm. The principle behind nearest neighbor methods is to find a predefined number of samples closest in distance to the new point. The distance can be any metric measure but the most common choice is the Euclidean distance. For a query image $q$ and a sample $s$, both of dimension $n$, this distance can be computed by the following formula. . begin{equation} d(q,s) = sqrt{(q_1-s_1)^2 + (q_2-s_2)^2 + … + (q_n-s_n)^2} end{equation} . In this example, we will retrieve the 5 closest images to the query image. . # Fit the NN algorithm to the encoded test set nbrs = NearestNeighbors(n_neighbors=5).fit(codes) # Find the closest images to the encoded query image distances, indices = nbrs.kneighbors(np.array(query_code)) . Results . These are the images we retrieved, it looks great ! All the retrieved images are pretty similar to our query image and they also all correspond to the same digit. This shows that the autoencoder, even without being shown the corresponding labels of the images, has found a way to encode similar images in a very similar way. . . Summary . In this article, we learned to create a very simple image retrieval system by using an autoencoder and the nearest-neighbors algorithm. We proceeded by training our autoencoder on a big dataset, to make it learn the way to encode efficiently the visual content of each image. We then compared the code of our query image to the codes of our searching dataset and retrieve the 5 closest. We saw that our system was giving pretty good results as the visual content of our 5 retrieved images was close to our query image and also that they all represented the same digit, even without using any label in the process. . . I hope this article was clear and useful for new Deep Learning practitioners and that it gave you a good insight on what image retrieval with autoencoders looks like ! Feel free to give me feedback or ask me questions is something is not clear enough. The whole code is available at this address! .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2018/08/24/image-retrieval.html",
            "relUrl": "/deep%20learning/2018/08/24/image-retrieval.html",
            "date": " • Aug 24, 2018"
        }
        
    
  
    
        ,"post6": {
            "title": "Deep Inside Autoencoders",
            "content": "Introduction . Autoencoders (AE) are neural networks that aims to copy their inputs to their outputs. They work by compressing the input into a latent-space representation, and then reconstructing the output from this representation. This kind of network is composed of two parts : . Encoder: This is the part of the network that compresses the input into a latent-space representation. It can be represented by an encoding function h=f(x)h=f(x)h=f(x). | Decoder: This part aims to reconstruct the input from the latent space representation. It can be represented by a decoding function $r=g(h)$. | . . Architecture of an Autoencoder . The autoencoder as a whole can thus be described by the function g(f(x))=rg(f(x)) = rg(f(x))=r where you want rrr as close as the original input xxx. . Why copying the input to the output ? . If the only purpose of autoencoders was to copy the input to the output, they would be useless. Indeed, we hope that, by training the autoencoder to copy the input to the output, the latent representation hhh will take on useful properties. . This can be achieved by creating constraints on the copying task. One way to obtain useful features from the autoencoder is to constrain hhh to have smaller dimensions than xxx, in this case the autoencoder is called undercomplete. By training an undercomplete representation, we force the autoencoder to learn the most salient features of the training data. If the autoencoder is given too much capacity, it can learn to perform the copying task without extracting any useful information about the distribution of the data. This can also occur if the dimension of the latent representation is the same as the input, and in the overcomplete case, where the dimension of the latent representation is greater than the input. In these cases, even a linear encoder and linear decoder can learn to copy the input to the output without learning anything useful about the data distribution. Ideally, one could train any architecture of autoencoder successfully, choosing the code dimension and the capacity of the encoder and decoder based on the complexity of distribution to be modeled. . . What are autoencoders used for ? . Today data denoising and dimensionality reduction for data visualization are considered as two main interesting practical applications of autoencoders. With appropriate dimensionality and sparsity constraints, autoencoders can learn data projections that are more interesting than PCA or other basic techniques. Autoencoders are learned automatically from data examples. It means that it is easy to train specialized instances of the algorithm that will perform well on a specific type of input and that it does not require any new engineering, only the appropriate training data. . However, autoencoders will do a poor job for image compression. As the autoencoder is trained on a given set of data, it will achieve reasonable compression results on data similar to the training set used but will be poor general-purpose image compressors. Compression techniques like JPEG will do vastly better. Autoencoders are trained to preserve as much information as possible when an input is run through the encoder and then the decoder, but are also trained to make the new representation have various nice properties. Different kinds of autoencoders aim to achieve different kinds of properties. We will focus on four types on autoencoders. . . Types of autoencoder : . In this article, the four following types of autoencoders will be described: . Vanilla autoencoder | Multilayer autoencoder | Convolutional autoencoder | Regularized autoencoder | . In order to illustrate the different types of autoencoder, an example of each has been created, using the Keras framework and the MNIST dataset. The code for each type of autoencoder is available on my GitHub. . Vanilla autoencoder . In its simplest form, the autoencoder is a three layers net, i.e. a neural net with one hidden layer. The input and output are the same, and we learn how to reconstruct the input, for example using the adam optimizer and the mean squared error loss function. . input_size = 784 hidden_size = 64 output_size = 784 x = Input(shape=(input_size,)) # Encoder h = Dense(hidden_size, activation=&#39;relu&#39;)(x) # Decoder r = Dense(output_size, activation=&#39;sigmoid&#39;)(h) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Here, we see that we have an undercomplete autoencoder as the hidden layer dimension (64) is smaller than the input (784). This constraint will impose our neural net to learn a compressed representation of data. . Multilayer autoencoder . If one hidden layer is not enough, we can obviously extend the autoencoder to more hidden layers. . input_size = 784 hidden_size = 128 code_size = 64 x = Input(shape=(input_size,)) # Encoder hidden_1 = Dense(hidden_size, activation=&#39;relu&#39;)(x) h = Dense(code_size, activation=&#39;relu&#39;)(hidden_1) # Decoder hidden_2 = Dense(hidden_size, activation=&#39;relu&#39;)(h) r = Dense(input_size, activation=&#39;sigmoid&#39;)(hidden_2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Now our implementation uses 3 hidden layers instead of just one. Any of the hidden layers can be picked as the feature representation but we will make the network symmetrical and use the middle-most layer. . Convolutional autoencoder . We may also ask ourselves: can autoencoders be used with Convolutions instead of Fully-connected layers ? . The answer is yes and the principle is the same, but using images (3D vectors) instead of flattened 1D vectors. The input image is downsampled to give a latent representation of smaller dimensions and force the autoencoder to learn a compressed version of the images. . x = Input(shape=(28, 28,1)) # Encoder conv1_1 = Conv2D(16, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) pool2 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) conv1_3 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool2) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_3) # Decoder conv2_1 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) conv2_3 = Conv2D(16, (3, 3), activation=&#39;relu&#39;)(up2) up3 = UpSampling2D((2, 2))(conv2_3) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up3) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Regularized autoencoder . There are other ways we can constraint the reconstruction of an autoencoder than to impose a hidden layer of smaller dimension than the input. Rather than limiting the model capacity by keeping the encoder and decoder shallow and the code size small, regularized autoencoders use a loss function that encourages the model to have other properties besides the ability to copy its input to its output. In practice, we usually find two types of regularized autoencoder: the sparse autoencoder and the denoising autoencoder. . Sparse autoencoder: Sparse autoencoders are typically used to learn features for another task such as classification. An autoencoder that has been regularized to be sparse must respond to unique statistical features of the dataset it has been trained on, rather than simply acting as an identity function. In this way, training to perform the copying task with a sparsity penalty can yield a model that has learned useful features as a byproduct. Another way we can constraint the reconstruction of autoencoder is to impose a constraint in its loss. We could, for example, add a reguralization term in the loss function. Doing this will make our autoencoder learn sparse representation of data. . input_size = 784 hidden_size = 64 output_size = 784 x = Input(shape=(input_size,)) # Encoder h = Dense(hidden_size, activation=&#39;relu&#39;, activity_regularizer=regularizers.l1(10e-5))(x) # Decoder r = Dense(output_size, activation=&#39;sigmoid&#39;)(h) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Notice in our hidden layer, we added an l1 activity regularizer, that will apply a penalty to the loss function during the optimization phase. As a result, the representation is now sparser compared to the vanilla autoencoder. . Denoising autoencoder : Rather than adding a penalty to the loss function, we can obtain an autoencoder that learns something useful by changing the reconstruction error term of the loss function. This can be done by adding some noise of the input image and make the autoencoder learn to remove it. By this means, the encoder will extract the most important features and learn a robuster representation of the data. . x = Input(shape=(28, 28, 1)) # Encoder conv1_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) # Decoder conv2_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . . Summary . In this article, we went through the basic architecture of autoencoders. We also looked at many different types of autoencoders: vanilla, multilayer, convolutional and regularized. Each has different properties depending on the imposed constraints : either the reduced dimension of the hidden layers or another kind of penalty. . . I hope this article was clear and useful for new Deep Learning practitioners and that it gave you a good insight on what autoencoders are ! Feel free to give me feed back or ask me questions is something is not clear enough. The whole code is available at this address! .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2018/02/25/deep-inside-autoencoders.html",
            "relUrl": "/deep%20learning/2018/02/25/deep-inside-autoencoders.html",
            "date": " • Feb 25, 2018"
        }
        
    
  

  
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nathanhubens.github.io/posts/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}