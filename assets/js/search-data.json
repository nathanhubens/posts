{
  
    
        "post0": {
            "title": "Neural Network Pruning",
            "content": "The curse of racing for high performance . While deep learning models are getting better in terms of performance, they also tend to get bigger and more expensive to compute. Until recently, it can seem that state-of-the-art models were achieved by using the good ol&#39; “Stack more layers !” property. Indeed, if you take a look at the history of state-of-the-art models on ImageNet, you will notice that each year, the new best results were achieved by using a deeper network. . It seems that we are obsessed by getting the best results as possible, leading to models that can involve hundreds of millions or parameters ! But what&#39;s the point of having a top-tier performing network if we cannot use it ? . . There has to be a better way to solve our tasks... . After all, as the philosopher William of Occam argued in his principle named after him, the Occam&#39;s Razor: . “Pluralitas non est ponenda sine necessitate.” . Or in other words: . “Simpler solutions should be favored over more complex ones.” . One of the ways to do so is to use a more parameter efficient architecture. There is a very active research going on in that field, and we can state some notable architectures that are competitive with their parameter-heavy equivalents (SqueezeNet1, MobileNet2, Xception3, EfficientNet4,...). . . Do we really need a sledgehammer to crack a nut ? . What if I told you that you can still use your favorite architecture, but in a more efficient way ? After all, neural networks are meant to be used either on ressource-constrained environments (mobile phones, autonomous cars, drones, ...) or to run on servers, so in both case, any gain in computation or memory storage would be beneficial. . Recently, there has been a very interesting paper by Frankle and Carbin5, where they introduce the lottery ticket hypothesis. This hypothesis states that, in a network, only a subset of the parameters are needed to achieve an optimal performance. The whole difficulty is then to find that particular subnetwork; the authors used a pruning technique consisting of pruning the trained model, then “rewinding” the initialization of remaining weights to their original initialization. Only that subnetwork, with that specific set of initialized weights is able to achieve the same level of accuracy as the entire network. . This discovery has huge implications, as it would imply that the only advantage of using parameter-heavy networks is to provide more initialization configuration and thus, more chance to get those “winning tickets”. . . Pruning . The inspiration behind neural network pruning is taken from how our own brain evolves during our life. Indeed, between our birth and adulthood, the amount of synapses (the structures that allows the neurons to transmit an electrical or chemical signal to another neuron) greatly varies. Our brain experience a large amount of growth during infancy, then basically follows a “use it or lose it” process. It results in a synaptic pruning which will remove any synapse that is not needed, in order to reach an optimal amount depending on our needs. . . In the case of neural networks, the principle of pruning is to remove network connections that are considered unimportant to keep the network performance unchanged. Pruning is actually a quite old idea (like most ideas of deep learning) but that is an active field of research nowadays. . It dates back to 1990s namely, with most popular work at that time being Optimal Brain Damage 6 and Optimal Brain Surgeon 7. Pruning has been popularized by Han et.al. 8 with their 2015 paper. . . Pruning thus consists of inducing sparsity in the weights of the network. . “Every block of stone has a statue inside it and it is the task of the sculptor to discover it.” - Michelangelo . As Michelangelo and his blocks of stone, we will carve our neural networks to bring their beauty out of them, or until we make them as sparse as possible while preserving their original performance. . . Granularity . Neural network pruning can come in many fashion, represented in the image below: . . You can either be very precise and remove each weight independently or remove bigger chunks at a time. The more fine-grained (or unstructured) the pruning, the more precise the process will be, but the more difficult it will be to get any acceleration. On the other hand, removing bigger chunks at a time (structured pruning) will be less accurate but will make life easier for any sparse matrices computation libraries. So granularity of pruning will be a trade-off between precision and acceleration. . . I guess it&#39;s a matter of preference, are you more a cubist or high renaissance deep learning artist ? . Apart from the granularity of pruning, you also have to choose when you will remove the weights. . . Scheduling . The timing and scheduling that you will adopt to prune your network will highly impact its final performance. . The three most commonly used schedulings are: . One-shot Pruning | Iterative Pruning | Automated Gradual Pruning | . The most basic idea is to start from a trained model, prune it to the desired sparsity, then optionally fine-tune the network to accomodate from the removal of some of its parameters. This technique is known as One-shot Pruning. However, a simple change to that technique is able to provide way better results. The idea is simply to perform the pruning phase over several steps, all followed by some fine-tuning. That technique is called Iterative Pruning and, while leading to better results, can sometimes be very time-consuming and computation intensive, especially if the number of parameters removed at each iteration is low. There has also been some research9 in incorporating weight pruning directly inside of the training step, periodically removing the weights. This technique is called Automated Gradual Pruning. . . . . In the case of Automated Gradual Pruning, the schedule proposed by the authors is the following: . . This schedule leads to an important pruning early in the training, then slowly decreasing as the training progresses. . . Criteria . Now that we know how and when to remove our parameters, we have to know which ones to choose. . There exists many ways to evaluate weights importance but the two most common ways are: . Weight Magnitude Pruning | Gradient Magnitude Pruning | . While being extremely simple, weight magnitude pruning has been found to be very effective. It simply consists of computing the $L1$-norm, i.e $ sum_{i} left|x_{i} right|$, of the weights (or group/kernel/filter depending on the granularity), and to remove the ones with the lowest values. In the case of gradient magnitude pruning, the only change is that we will multiply our weights by their corresponding gradients before computing the $L1$-norm on the result. . Those criteria can be evaluated locally, i.e. each channel is pruned until the desired sparsity is reached, resulting in equally sparse layers, or globally, i.e. we evaluate the weights over the whole network, resulting in a sparse network, but with layers having different sparsity values. . . Evaluation . In order to report how well a pruning technique is doing, you need metrics to evaluate it. . To avoid any ambiguity in metrics used, Davis Blalock and Jose Javier Gonzalez Ortiz10 have proposed a library to unify the way we report metrics. More specifically they propose to report: . Compression Ratio, which should be computed as: Compression Ratio = total_params/nonzero_params, with total_params being the original number of parameters in the network and nonzero_params the number of non-zero weights after pruning. . | Theoretical Speed-Up, which should be computed as: Speed-up = total_flops/nonzero_flops, with total_flops being the amount of FLOPs in the original model and nonzero_flops the amount of FLOPs of the remaining non-zero weights. . | . It is important to report both metrics as the speed-up greatly depends on where in the network the pruning is performed. Indeed, for a same compression ratio, two similar architectures can have widely different speed-up values. This is because the FLOPs of the convolution operation highly depend on the size of their input dimension, which varies along the network. Most of parameters are usually contained towards the end of the network while most of the computation is performed in early layers, reason why early downsampling is widely used. . The graph below show how the number of parameters and FLOPs evolve in the VGG16 network: . . What it shows is that, the last 3 layers hold $48 %$ of the parameters while being only responsible of $9 %$ of the total FLOPs in the network. For that reason, in order to see the same speed-up improvement, you will need to remove a lot more parameters in late layers than you would need in early layers. . Another problem remaining is that the reported speed-up is a theoretical value. It means that you&#39;ll never observe such a speed-up in reality, especially because common deep learnings do not support acceleration for sparse matrices, or that it requires dedicated hardware. The easiest way to make sure that you will get an inference speed improvement is to physically remove the weights (can only be done for entire filters 11), you don&#39;t need to take care of sparse matrices computations if you don&#39;t have the matrix anymore! The way to perform that operation for a layer $i$ is the following: . . As you remove a whole filter, it&#39;s not really introducing sparsity in the network as you now change an hyperparameter (number of filter in a layer). Moreover, if you decide to prune a single filter in layer $i$, it means that the corresponding feature map won&#39;t exist anymore. Thus, in the layer $i+1$, the kernels corresponding to the deleted feature maps have to be removed. So, pruning a filter saves parameters and computations both in the current layer and in the following one ! . . That&#39;s all ! Thank you for reading, I hope that you found this little tour over neural network pruning interesting and, more importantly, useful. . . . . If you notice any mistake or improvement that can be done, please contact me ! If you found that post useful, please consider citing it as: . @article{hubens2020pruning, title = &quot;Neural Network Pruning&quot;, author = &quot;Hubens, Nathan&quot;, journal = &quot;nathanhubens.github.io&quot;, year = &quot;2020&quot;, url = &quot;https://nathanhubens.github.io/posts/deep%20learning/2020/05/22/pruning.html&quot; } . . References . 1. Howard A. et al., SqueezeNet: AlexNet-level accuracy with 50x fewer parameters and &lt;1MB model size. ICLR, 2017↩ . | 2. Forrest N. Iandola et al., MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications. CoRR, abs/1704.04861, 2017↩ . | 3. Chollet F., Xception: Deep Learning with Depthwise Separable Convolutions. CVPR, 2017↩ . | 4. Mingxing T. and Quoc V. Le, EfficientNet: Rethinking Model Scaling for Convolutional Neural Networks. ICML, 2019↩ . | 5. Frankle, J. &amp; Carbin, M., The Lottery Ticket Hypothesis: Finding Sparse, Trainable Neural Networks. ICLR, 2019↩ . | 6. LeCun Y. and Denker J. and Solla S., Optimal Brain Damage, NeurIPS, 1990↩ . | 7. Hassibi, Babak and David G. Stork and Wolff, Gregory, Optimal Brain Surgeon: Extensions and performance comparisons, NeurIPS, 1993↩ . | 8. Han S. et al., Learning both Weights and Connections for Efficient Neural Networks, NeurIPS, 2015↩ . | 9. Zhu, M. &amp; Gupta, S. To prune, or not to prune: exploring the efficacy of pruning for model compression. ICLR, 2018↩ . | 10. Blalock D.,Gonzalez Ortiz J.,Frankle J., and Guttag J., What is the state of neural network pruning?. MLSys, 2020↩ . | 11. Hao Li et al., Pruning Filters for Efficient ConvNets, ICLR, 2017↩ . | .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2020/05/22/pruning.html",
            "relUrl": "/deep%20learning/2020/05/22/pruning.html",
            "date": " • May 22, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Speed-up inference with Batch Normalization Folding",
            "content": "Introduction . Batch Normalization 1 2 is a technique which takes care of normalizing the input of each layer to make the training process faster and more stable. In practice, it is an extra layer that we generally add after the computation layer and before the non-linearity. . It consists of 2 steps: . Normalize the batch by first subtracting its mean $ mu$, then dividing it by its standard deviation $ sigma$. | Further scale by a factor $ gamma$ and shift by a factor $ beta$. Those are the parameters of the batch normalization layer, required in case of the network not needing the data to have a mean of 0 and a standard deviation of 1. | $$ Large begin{aligned} &amp; mu_{ mathcal{B}} leftarrow frac{1}{m} sum_{i=1}^{m} x_{i} &amp; sigma_{ mathcal{B}}^{2} leftarrow frac{1}{m} sum_{i=1}^{m} left(x_{i}- mu_{ mathcal{B}} right)^{2} &amp; widehat{x}_{i} leftarrow frac{x_{i}- mu_{ mathcal{B}}}{ sqrt{ sigma_{ mathcal{B}}^{2}+ epsilon}} &amp;y_{i} leftarrow gamma widehat{x}_{i}+ beta equiv mathrm{BN}_{ gamma, beta} left(x_{i} right) end{aligned} $$ Due to its efficiency for training neural networks, batch normalization is now widely used. But how useful is it at inference time? . Once the training has ended, each batch normalization layer possesses a specific set of $ gamma$ and $ beta$, but also $ mu$ and $ sigma$, the latter being computed using an exponentially weighted average during training. It means that during inference, the batch normalization acts as a simple linear transformation of what comes out of the previous layer, often a convolution. . As a convolution is also a linear transformation, it also means that both operations can be merged into a single linear transformation! . This would remove some unnecessary parameters but also reduce the number of operations to be performed at inference time. . . . How to do that in practice? . With a little bit of math, we can easily rearrange the terms of the convolution to take the batch normalization into account. . As a little reminder, the convolution operation followed by the batch normalization operation can be expressed, for an input $x$, as: . $$ Large begin{aligned} z &amp;=W * x+b text { out } &amp;= gamma cdot frac{z- mu}{ sqrt{ sigma^{2}+ epsilon}}+ beta end{aligned} $$So, if we re-arrange the $W$ and $b$ of the convolution to take the parameters of the batch normalization into account, as such: . $$ Large begin{aligned} w_{ text {fold }} &amp;= gamma cdot frac{W}{ sqrt{ sigma^{2}+ epsilon}} b_{ text {fold }} &amp;= gamma cdot frac{b- mu}{ sqrt{ sigma^{2}+ epsilon}}+ beta end{aligned} $$We can remove the batch normalization layer and still have the same results! . . Note: Usually, you don’t have a bias in a layer preceding a batch normalization layer. It is useless and a waste of parameters as any constant will be canceled out by the batch normalization. . . . How efficient is it? . We will try for 2 common architectures: . VGG16 with batch norm | ResNet50 | Just for the demonstration, we will use ImageNette dataset and PyTorch. Both networks will be trained for 5 epochs and what changes in terms of parameter number and inference time. . . VGG16 . Let’s start by training VGG16 for 5 epochs (the final accuracy doesn’t matter): . epoch train_loss valid_loss accuracy time . 0 | 1.985012 | 3.945934 | 0.226497 | 00:31 | . 1 | 1.868819 | 1.620619 | 0.472611 | 00:31 | . 2 | 1.574975 | 1.295385 | 0.576815 | 00:31 | . 3 | 1.305211 | 1.161460 | 0.617325 | 00:32 | . 4 | 1.072395 | 0.955824 | 0.684076 | 00:32 | . Then show its number of parameters: . Total parameters : 134,309,962 . We can get the initial inference time by using the %%timeit magic command: . %%timeit model(x[0][None].cuda()) . 2.77 ms ± 1.65 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . So now if we apply batch normalization folding, we have: . Total parameters : 134,301,514 . And: . %%timeit folded_model(x[0][None].cuda()) . 2.41 ms ± 2.49 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . So 8448 parameters removed and even better, almost 0.4 ms faster inference! Most importantly, this is completely lossless, there is absolutely no change in terms of performance: . folded_learner.validate() . [0.9558241, tensor(0.6841)] . Let’s see how it behaves in the case of Resnet50! . . Resnet50 . Same, we start by training it for 5 epochs: . epoch train_loss valid_loss accuracy time . 0 | 2.076416 | 2.491038 | 0.246624 | 00:20 | . 1 | 1.696750 | 1.517581 | 0.489427 | 00:19 | . 2 | 1.313028 | 1.206347 | 0.606115 | 00:20 | . 3 | 1.057600 | 0.890211 | 0.716943 | 00:21 | . 4 | 0.828224 | 0.793130 | 0.740892 | 00:19 | . The initial amount of parameters is: . Total parameters : 23,528,522 . And inference time is: . %%timeit model(x[0][None].cuda()) . 6.17 ms ± 13.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . After using batch normalization folding, we have: . Total parameters : 23,501,962 . And: . %%timeit final_model(x[0][None].cuda()) . 4.47 ms ± 8.97 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) . So now, we have 26,560 parameters removed and even more impressive, an inference time reduce by 1.7ms! And still without any drop in performance. . final_learner.validate() . [0.7931296, tensor(0.7409)] . . So if we can reduce the inference time and the number of parameters of our models without enduring any drop in performance, why shouldn’t we always do it? . . I hope that this blog post helped you! Feel free to give me feedback or ask me questions is something is not clear enough. . Code available at this address! . . . References . 1. The Batch Normalization paper↩ . | 2. DeepLearning.ai Batch Normalization Lesson↩ . | .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2020/04/20/BN.html",
            "relUrl": "/deep%20learning/2020/04/20/BN.html",
            "date": " • Apr 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Build a simple Image Retrieval System with an Autoencoder",
            "content": "Image retrieval is a very active and fast-advancing field of research area in the past decade. The most well-known systems being the Google Image Search and Pinterest Visual Pin Search. In this article, we will learn to build a very simple image retrieval system using a special type of Neural Network, called an autoencoder. The way we are going to proceed is in an unsupervised way, i.e without looking at the image labels. Indeed, we will retrieve images only by using their visual contents (textures, shapes,…). This type of image retrieval is called content-based image retrieval (CBIR), opposed to keywords or text-based image retrieval. For this article, we will use images of handwritten digits, the MNIST dataset and the Keras deep-learning framework. . . Autoencoders . Briefly, autoencoders are neural networks that aims to copy their inputs to their outputs. They work by compressing the input into a latent-space representation, and then reconstructing the output from this representation.This kind of network is composed of two parts : . Encoder: This is the part of the network that compresses the input into a latent-space representation. It can be represented by an encoding function $h=f(x)$. . | Decoder: This part aims to reconstruct the input from the latent space representation. It can be represented by a decoding function $r=g(h)$. . | . . If you want to learn more about autoencoders, I suggest you to read my previous blog post. . . This latent representation, or code, is what will interest us here as it is the way the neural network as found to compress the visual content about each image. It means that all of similar images will be encoded (hopefully) in a similar way. There are several types of autoencoders but since we are dealing with images, the most efficient is to use a convolutional autoencoder, that uses convolution layers to encode and decode images. . x = Input(shape=(28, 28, 1)) # Encoder conv1_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) # Decoder conv2_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . The first step is thus to train our autoencoder with our training set, to make it learn the way to encode our images into a latent-space representation. Once the training as been performed, we only need the encoding part of the network. . encoder = Model(inputs=autoencoder.input, outputs=autoencoder.get_layer(&#39;encoder&#39;).output) . This encoder can now be used to encode our query image. . . The same encoding must be done on our searching database, where we want to find similar images to the query image. We can then compare the query code to the database code and try to find the closest ones. To perform this comparison, we will use the nearest-neighbors technique. . Nearest-neighbors . The way we are going to retrieve the closest codes is by performing the nearest-neighbors algorithm. The principle behind nearest neighbor methods is to find a predefined number of samples closest in distance to the new point. The distance can be any metric measure but the most common choice is the Euclidean distance. For a query image $q$ and a sample $s$, both of dimension $n$, this distance can be computed by the following formula. . begin{equation} d(q,s) = sqrt{(q_1-s_1)^2 + (q_2-s_2)^2 + … + (q_n-s_n)^2} end{equation} . In this example, we will retrieve the 5 closest images to the query image. . # Fit the NN algorithm to the encoded test set nbrs = NearestNeighbors(n_neighbors=5).fit(codes) # Find the closest images to the encoded query image distances, indices = nbrs.kneighbors(np.array(query_code)) . Results . These are the images we retrieved, it looks great ! All the retrieved images are pretty similar to our query image and they also all correspond to the same digit. This shows that the autoencoder, even without being shown the corresponding labels of the images, has found a way to encode similar images in a very similar way. . . Summary . In this article, we learned to create a very simple image retrieval system by using an autoencoder and the nearest-neighbors algorithm. We proceeded by training our autoencoder on a big dataset, to make it learn the way to encode efficiently the visual content of each image. We then compared the code of our query image to the codes of our searching dataset and retrieve the 5 closest. We saw that our system was giving pretty good results as the visual content of our 5 retrieved images was close to our query image and also that they all represented the same digit, even without using any label in the process. . . I hope this article was clear and useful for new Deep Learning practitioners and that it gave you a good insight on what image retrieval with autoencoders looks like ! Feel free to give me feedback or ask me questions is something is not clear enough. The whole code is available at this address! .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2018/08/24/image-retrieval.html",
            "relUrl": "/deep%20learning/2018/08/24/image-retrieval.html",
            "date": " • Aug 24, 2018"
        }
        
    
  
    
        ,"post3": {
            "title": "Deep Inside Autoencoders",
            "content": "Introduction . Autoencoders (AE) are neural networks that aims to copy their inputs to their outputs. They work by compressing the input into a latent-space representation, and then reconstructing the output from this representation. This kind of network is composed of two parts : . Encoder: This is the part of the network that compresses the input into a latent-space representation. It can be represented by an encoding function h=f(x)h=f(x)h=f(x). | Decoder: This part aims to reconstruct the input from the latent space representation. It can be represented by a decoding function $r=g(h)$. | . . Architecture of an Autoencoder . The autoencoder as a whole can thus be described by the function g(f(x))=rg(f(x)) = rg(f(x))=r where you want rrr as close as the original input xxx. . Why copying the input to the output ? . If the only purpose of autoencoders was to copy the input to the output, they would be useless. Indeed, we hope that, by training the autoencoder to copy the input to the output, the latent representation hhh will take on useful properties. . This can be achieved by creating constraints on the copying task. One way to obtain useful features from the autoencoder is to constrain hhh to have smaller dimensions than xxx, in this case the autoencoder is called undercomplete. By training an undercomplete representation, we force the autoencoder to learn the most salient features of the training data. If the autoencoder is given too much capacity, it can learn to perform the copying task without extracting any useful information about the distribution of the data. This can also occur if the dimension of the latent representation is the same as the input, and in the overcomplete case, where the dimension of the latent representation is greater than the input. In these cases, even a linear encoder and linear decoder can learn to copy the input to the output without learning anything useful about the data distribution. Ideally, one could train any architecture of autoencoder successfully, choosing the code dimension and the capacity of the encoder and decoder based on the complexity of distribution to be modeled. . . What are autoencoders used for ? . Today data denoising and dimensionality reduction for data visualization are considered as two main interesting practical applications of autoencoders. With appropriate dimensionality and sparsity constraints, autoencoders can learn data projections that are more interesting than PCA or other basic techniques. Autoencoders are learned automatically from data examples. It means that it is easy to train specialized instances of the algorithm that will perform well on a specific type of input and that it does not require any new engineering, only the appropriate training data. . However, autoencoders will do a poor job for image compression. As the autoencoder is trained on a given set of data, it will achieve reasonable compression results on data similar to the training set used but will be poor general-purpose image compressors. Compression techniques like JPEG will do vastly better. Autoencoders are trained to preserve as much information as possible when an input is run through the encoder and then the decoder, but are also trained to make the new representation have various nice properties. Different kinds of autoencoders aim to achieve different kinds of properties. We will focus on four types on autoencoders. . . Types of autoencoder : . In this article, the four following types of autoencoders will be described: . Vanilla autoencoder | Multilayer autoencoder | Convolutional autoencoder | Regularized autoencoder | . In order to illustrate the different types of autoencoder, an example of each has been created, using the Keras framework and the MNIST dataset. The code for each type of autoencoder is available on my GitHub. . Vanilla autoencoder . In its simplest form, the autoencoder is a three layers net, i.e. a neural net with one hidden layer. The input and output are the same, and we learn how to reconstruct the input, for example using the adam optimizer and the mean squared error loss function. . input_size = 784 hidden_size = 64 output_size = 784 x = Input(shape=(input_size,)) # Encoder h = Dense(hidden_size, activation=&#39;relu&#39;)(x) # Decoder r = Dense(output_size, activation=&#39;sigmoid&#39;)(h) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Here, we see that we have an undercomplete autoencoder as the hidden layer dimension (64) is smaller than the input (784). This constraint will impose our neural net to learn a compressed representation of data. . Multilayer autoencoder . If one hidden layer is not enough, we can obviously extend the autoencoder to more hidden layers. . input_size = 784 hidden_size = 128 code_size = 64 x = Input(shape=(input_size,)) # Encoder hidden_1 = Dense(hidden_size, activation=&#39;relu&#39;)(x) h = Dense(code_size, activation=&#39;relu&#39;)(hidden_1) # Decoder hidden_2 = Dense(hidden_size, activation=&#39;relu&#39;)(h) r = Dense(input_size, activation=&#39;sigmoid&#39;)(hidden_2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Now our implementation uses 3 hidden layers instead of just one. Any of the hidden layers can be picked as the feature representation but we will make the network symmetrical and use the middle-most layer. . Convolutional autoencoder . We may also ask ourselves: can autoencoders be used with Convolutions instead of Fully-connected layers ? . The answer is yes and the principle is the same, but using images (3D vectors) instead of flattened 1D vectors. The input image is downsampled to give a latent representation of smaller dimensions and force the autoencoder to learn a compressed version of the images. . x = Input(shape=(28, 28,1)) # Encoder conv1_1 = Conv2D(16, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) pool2 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) conv1_3 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool2) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_3) # Decoder conv2_1 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(8, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) conv2_3 = Conv2D(16, (3, 3), activation=&#39;relu&#39;)(up2) up3 = UpSampling2D((2, 2))(conv2_3) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up3) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Regularized autoencoder . There are other ways we can constraint the reconstruction of an autoencoder than to impose a hidden layer of smaller dimension than the input. Rather than limiting the model capacity by keeping the encoder and decoder shallow and the code size small, regularized autoencoders use a loss function that encourages the model to have other properties besides the ability to copy its input to its output. In practice, we usually find two types of regularized autoencoder: the sparse autoencoder and the denoising autoencoder. . Sparse autoencoder: Sparse autoencoders are typically used to learn features for another task such as classification. An autoencoder that has been regularized to be sparse must respond to unique statistical features of the dataset it has been trained on, rather than simply acting as an identity function. In this way, training to perform the copying task with a sparsity penalty can yield a model that has learned useful features as a byproduct. Another way we can constraint the reconstruction of autoencoder is to impose a constraint in its loss. We could, for example, add a reguralization term in the loss function. Doing this will make our autoencoder learn sparse representation of data. . input_size = 784 hidden_size = 64 output_size = 784 x = Input(shape=(input_size,)) # Encoder h = Dense(hidden_size, activation=&#39;relu&#39;, activity_regularizer=regularizers.l1(10e-5))(x) # Decoder r = Dense(output_size, activation=&#39;sigmoid&#39;)(h) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . Notice in our hidden layer, we added an l1 activity regularizer, that will apply a penalty to the loss function during the optimization phase. As a result, the representation is now sparser compared to the vanilla autoencoder. . Denoising autoencoder : Rather than adding a penalty to the loss function, we can obtain an autoencoder that learns something useful by changing the reconstruction error term of the loss function. This can be done by adding some noise of the input image and make the autoencoder learn to remove it. By this means, the encoder will extract the most important features and learn a robuster representation of the data. . x = Input(shape=(28, 28, 1)) # Encoder conv1_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(x) pool1 = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_1) conv1_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(pool1) h = MaxPooling2D((2, 2), padding=&#39;same&#39;)(conv1_2) # Decoder conv2_1 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(h) up1 = UpSampling2D((2, 2))(conv2_1) conv2_2 = Conv2D(32, (3, 3), activation=&#39;relu&#39;, padding=&#39;same&#39;)(up1) up2 = UpSampling2D((2, 2))(conv2_2) r = Conv2D(1, (3, 3), activation=&#39;sigmoid&#39;, padding=&#39;same&#39;)(up2) autoencoder = Model(input=x, output=r) autoencoder.compile(optimizer=&#39;adam&#39;, loss=&#39;mse&#39;) . . Summary . In this article, we went through the basic architecture of autoencoders. We also looked at many different types of autoencoders: vanilla, multilayer, convolutional and regularized. Each has different properties depending on the imposed constraints : either the reduced dimension of the hidden layers or another kind of penalty. . . I hope this article was clear and useful for new Deep Learning practitioners and that it gave you a good insight on what autoencoders are ! Feel free to give me feed back or ask me questions is something is not clear enough. The whole code is available at this address! .",
            "url": "https://nathanhubens.github.io/posts/deep%20learning/2018/02/25/deep-inside-autoencoders.html",
            "relUrl": "/deep%20learning/2018/02/25/deep-inside-autoencoders.html",
            "date": " • Feb 25, 2018"
        }
        
    
  

  
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://nathanhubens.github.io/posts/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}